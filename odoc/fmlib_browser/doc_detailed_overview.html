<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>doc_detailed_overview (fmlib_browser.doc_detailed_overview)</title><meta charset="utf-8"/><link rel="stylesheet" href="../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="index.html">Up</a> – <a href="../index.html">Index</a> &#x00BB; <a href="index.html">fmlib_browser</a> &#x00BB; doc_detailed_overview</nav><header class="odoc-preamble"><h1 id="a-more-detailed-overview"><a href="#a-more-detailed-overview" class="anchor"></a>A More Detailed Overview</h1><p><a href="doc_single_page_application.html" title="doc_single_page_application">Writing a single-page application</a> | <a href="doc.html" title="doc">Up</a> | <a href="doc_reference_elements.html" title="doc_reference_elements">Optimizing Big Applications with Reference Elements</a></p></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#essential-parts">Essential Parts</a></li><li><a href="#rendering---accessing-the-dom">Rendering - Accessing the DOM</a><ul><li><a href="#event-loop-with-animation">Event Loop with Animation</a></li><li><a href="#is-the-state-immutable?---more-optimizations">Is the State Immutable? - More Optimizations</a></li></ul></li><li><a href="#different-types-of-applications">Different Types of Applications</a></li><li><a href="#interoperation-with-javascript">Interoperation with Javascript</a><ul><li><a href="#initialisation">Initialisation</a></li><li><a href="#send-and-receive-messages">Send and Receive Messages</a></li></ul></li></ul></nav></div><div class="odoc-content"><h2 id="essential-parts"><a href="#essential-parts" class="anchor"></a>Essential Parts</h2><p>As seen in the previous chapters a webapplication written with the help of <a href="Fmlib_browser/index.html"><code>Fmlib_browser</code></a> has the following essential components.</p><pre class="language-ocaml"><code>    type state
    type msg

    val view:         state -&gt; msg Html.t
    val subscription: state -&gt; msg Subscription.t
    val update:       state -&gt; msg -&gt; state -&gt; msg Command.t</code></pre><p>The type <code>state</code> contains all data the application needs to operate. All changes are done via message passing by using object of type <code>msg</code>.</p><p>The <code>view</code> function maps the state of the application to a virtual dom of type <code>msg Html.t</code> (see <a href="Fmlib_browser/Html/index.html"><code>Fmlib_browser.Html</code></a>). Each element in the virtual dom might contain interactive attributes which are clickable, can enter text, ... (see <a href="Fmlib_browser/Attribute/index.html"><code>Fmlib_browser.Attribute</code></a>). Each interaction with an interactive element in the virtual dom creates an object of type <code>msg</code> which is dispatched to the application via its <code>update</code> function.</p><p>The <code>view</code> function is called usually on each animation which is typically 60 times per second. It is called at each animation only if the state has changed.</p><p>A second way for the application to get messages is via subscriptions (see <a href="Fmlib_browser/Subscription/index.html"><code>Fmlib_browser.Subscription</code></a>). Via the <code>subscription</code> function the application can depending on the state subscribe to global events like interval timers, windows resize, mouse clicks an keyboard activities which bubble up to the windows object of the browser, ...</p><p>Each time the state changes the function <code>subscription</code> will be called to get all the subscriptions needed in the new state.</p><p>All messages passed to the application go through the <code>update</code> function. The function receives the current state and a message and it produces a new state and a possibly empty set of commands.</p><p>Commands can be used to send http requests, get the current time, generate a random number, focus an element, put something into or get something from the browser local or session storage (see <a href="Fmlib_browser/Command/index.html"><code>Fmlib_browser.Command</code></a>). Very complex commands (e.g. get a random number, then make a http request, then get the system time and finally put all results into one message) can be structured via tasks (see <a href="Fmlib_browser/Task/index.html"><code>Fmlib_browser.Task</code></a>) which are triggered via a command.</p><h2 id="rendering---accessing-the-dom"><a href="#rendering---accessing-the-dom" class="anchor"></a>Rendering - Accessing the DOM</h2><p>In many applications the most expensive part is accessing the DOM. In the library there are several mechanisms to make DOM changes cheap.</p><h3 id="event-loop-with-animation"><a href="#event-loop-with-animation" class="anchor"></a>Event Loop with Animation</h3><p>In the browser there is an event loop.</p><pre>
                  +------------------------------&gt;+--------&gt;+
                  ^                               |         |
                  |                               |  rAF    |
                  |                               |         |
      +--+--+--+  |                               |  style  |
      |  |  |  |  |        event loop             |         |
      +--+--+--+  |                               |  layout |
                  |                               |         |
     Action Queue |                               |  render |
                  |                               v         v
                  +&lt;------------------------------+&lt;--------+
</pre><p>The event loop runs very fast. The event loop pulls out the next atomic action from the action queue, runs it and then enters the next iteration.</p><p>If a user interaction (e.g. a mouse click) happens on an element of the dom, the corresponding message is generated, the message is fed into the update function, the new state is recorded and the first action of the corresponding command is entered into the action queue. The actions are executed in the next iterations of the event loop.</p><p>The same happens if message is generated from a subscription.</p><p>The inner event loop iterates until the next animation frame happens. Each animation frame the event loop runs the extended event loop before pulling out the next action from the action queue. Usually the browser has 60 animations per second i.e. the animation frame is executed every 16ms approximately.</p><p>If your application has subscribed to the animation frame (see <a href="Fmlib_browser/Subscription/index.html#val-on_animation"><code>Fmlib_browser.Subscription.on_animation</code></a> <code>rAF</code> is run i.e. the message for this subscription is generated and fed into the update function.</p><p>Even if your application is not subscribed to the animation frame, the <a href="Fmlib_browser/index.html"><code>Fmlib_browser</code></a> accesses during <code>rAF</code> the dom.</p><ol><li>Check if the state has changed. If it has not changed nothing is done here. The changing of the state is computed by physical equality i.e. <code>old_state == new_state</code>.</li><li>If the state has changed then the virtual dom is computed by calling the <code>view</code> function.</li><li>The new virtual dom is compared with the old virtual dom. The real dom is accessed only if a dom element or one of its attributes have changed. If the type of the element (i.e. its tag) has changed, then a new element is created. If the type has not changed, the attributes are compared and updated in the real dom element only if they have changed.</li></ol><p>The <a href="Fmlib_browser/index.html"><code>Fmlib_browser</code></a> minimizes accesses to the dom and accesses the dom only during animation frames.</p><h3 id="is-the-state-immutable?---more-optimizations"><a href="#is-the-state-immutable?---more-optimizations" class="anchor"></a>Is the State Immutable? - More Optimizations</h3><p>In a previous chapter it has been stated that the state should be immutable. I.e. state changes happen by the expression</p><pre class="language-ocaml"><code>    {state with field1 = ...; fieldn = ... ; ... }</code></pre><p>This means that the OCaml compiler generates a new state object which has the content of the old object with some modifications. If the state contains a mutable <code>field5</code> an update of the state could happen by the expression</p><pre class="language-ocaml"><code>    state.field5 &lt;- ...;</code></pre><p>In this case the compiler does no create a new object but modifies the object in place. If this is the only modification of the state, then <a href="Fmlib_browser/index.html"><code>Fmlib_browser</code></a> does not recognize the state as changed and does not update the dom in the next animation frame.</p><p>Therefore the first recommendation in the introduction has been, <em>Do not do that!</em>. However this rule is too strong. The library <a href="Fmlib_browser/index.html"><code>Fmlib_browser</code></a> holds only one reference to the state. Therefore in principle it could be modified in place as long as the modification does not affect the <code>view</code> function.</p><p>Now the more precise rule:</p><ul><li><p>Every update of the state which affects the result of the <code>view</code> function must have the form</p><pre>    {state with field1 = ...; field2 = ...; ...}</pre></li><li><p>Modifications of the state which do <em>not</em> change the result of the <code>view</code> function can have the form</p><pre>     state.field5 &lt;- ...;</pre></li></ul><p>This opens up the room for more optimizations. Your application might have messages which do not change the rendering of the page. For these cases it is possible to record the changes caused by these messages in mutable fields in the state. Then nothing is done in the next animation frame.</p><p>Example: You have a complex computation to do in your application but you don't want to block the event loop for the whole computation. So you split the computation into small steps. Each step creates at the end a message which is fed into the <code>update</code> function. The <code>update</code> function just creates a command for the next step and records the intermediate state of the computation in some mutable fields of the application state. Then nothing is done in the next animation frame. Only the last step of the computation is recorded in the application state in immutables fields, a new object is created by the OCaml runtime system and the <code>view</code> function will be called in the next animation frame and the result is displayed.</p><p>A word of caution: Such optimizations only make sense if your virtual dom is <em>really</em> huge. For reasonably sized virtual doms the optimization effect is negligible.</p><p>If the dom of an application is huge such that virtual dom diffing can have a significant impact on performance (i.e. blocking the event loop in the animation frame too long) consider the use of <a href="doc_reference_elements.html" title="doc_reference_elements">reference elements</a> where the part of the application state visible in reference elements can be stored in mutable fields.</p><h2 id="different-types-of-applications"><a href="#different-types-of-applications" class="anchor"></a>Different Types of Applications</h2><p>The library <a href="Fmlib_browser/index.html"><code>Fmlib_browser</code></a> offers different types of applications.</p><ol><li><p>Sandbox applications: <a href="Fmlib_browser/index.html#val-sandbox" title="Fmlib_browser.sandbox"><code>sandbox</code></a> and <a href="Fmlib_browser/index.html#val-sandbox_plus" title="Fmlib_browser.sandbox_plus"><code>sandbox_plus</code></a></p><ul><li>Sandbox applications only display a dom and have interactions via attributes on dom elements (e.g. clickable elements). <code>sandbox_plus</code> has the additional possibility to subscribe to events.</li><li>There is no possibility to initialize the application via javascript code in the html file nor can it execute any commands nor can it interact with the javascript world.</li><li>The whole body of the dom is controlled by the sandbox applications</li><li>The main purpose of sandbox applications is to try out the library and get a feel on how it works.</li></ul><p></p></li><li><p>Element applications:</p><p>The purpose of <a href="Fmlib_browser/index.html#val-element" title="Fmlib_browser.element"><code>element</code></a> applications is to introduce the library <a href="Fmlib_browser/index.html"><code>Fmlib_browser</code></a> smoothly into applications already written in javascript.</p><ul><li>An element application is integrated into the main application below an element of the main application.</li><li>It has full control over the dom element and the dom below the element and it has no access to dom elements outside.</li><li>It can be initialized from the javascript code of the main application and can send messages to and receive messages from the main javascript application.</li><li>It has the possibility to subscribe to events and execute commands.</li><li>It cannot access the browser history via <code>push_url</code> etc.</li></ul><p></p></li><li><p>Web applications: <a href="Fmlib_browser/index.html#val-basic_application" title="Fmlib_browser.basic_application"><code>basic_application</code></a> and <a href="Fmlib_browser/index.html#val-application" title="Fmlib_browser.application"><code>application</code></a></p><ul><li>Web applications control the body of the dom and the title of the browser window</li><li>They have subscriptions and can execute commands.</li><li>The <code>basic_application</code> cannot be initialized by javascript code, cannot send and receive messages from and to javascript code and cannot access the browser history.</li><li>An <code>application</code> can be initialized by javascript code, it can communicate with the javascript code and has access to the browser history via <a href="Fmlib_browser/Command/index.html#val-push_url"><code>Fmlib_browser.Command.push_url</code></a> etc.</li><li>In an <code>application</code> all user clicks on anchor elements with <code>href</code>s are intercepted and the application has full control on what happens with these clicks (see <a href="doc_single_page_application.html"><code>doc_single_page_application</code></a>).</li></ul><p></p></li></ol><p>Full web applications can do everything what can be done with pure javascript code in the browser. Anything no directly supported by the library <a href="Fmlib_browser/index.html"><code>Fmlib_browser</code></a> can be done by writing javascript code in the browser and trigger the corresponding operations by sending messages to javascript and receive messages from javascript.</p><p>There are commands to send a message to javascript and the application can subscribe to messages received from javascript.</p><h2 id="interoperation-with-javascript"><a href="#interoperation-with-javascript" class="anchor"></a>Interoperation with Javascript</h2><p><a href="Fmlib_browser/index.html#val-element" title="Fmlib_browser.element"> Element applications</a> and <a href="Fmlib_browser/index.html#val-application" title="Fmlib_browser.application"> full web applications</a> can communicate with javascript code in the browser.</p><h3 id="initialisation"><a href="#initialisation" class="anchor"></a>Initialisation</h3><p>In order to receive initialisation data the web application is given unique name which is visible in the namespace of a browser window.</p><p>This name refers to an object which has a method to receive javascript initialisation object.</p><p>On the application side a <a href="Fmlib_browser/Decoder/index.html" title="Fmlib_browser.Decoder">decoder object</a> is needed to transform the javascript object into the OCaml word.</p><p>See <a href="Fmlib_browser/index.html#val-element"><code>Fmlib_browser.element</code></a> and <a href="Fmlib_browser/index.html#val-application"><code>Fmlib_browser.application</code></a> for details.</p><h3 id="send-and-receive-messages"><a href="#send-and-receive-messages" class="anchor"></a>Send and Receive Messages</h3><p>The can issue the command <a href="Fmlib_browser/Command/index.html#val-send_to_javascript" title="Fmlib_browser.Command.send_to_javascript"><code>send_to_javascript</code></a> which sends a javascript object made by <a href="Fmlib_browser/Value/index.html"><code>Fmlib_browser.Value</code></a>.</p><p>The javascript code can subscribe to the messages from the application via the unique name of the application. The name refers to an object which has a corresponding method.</p><p>Furthermore object representing the application has a method to post a message on the javascript side to the application. The application can subscribe to the messages from the javascript side by providing a <a href="Fmlib_browser/Decoder/index.html" title="Fmlib_browser.Decoder">decoder</a> to transform the javascript object to the OCaml world.</p><p>See <a href="Fmlib_browser/index.html#val-element"><code>Fmlib_browser.element</code></a> and <a href="Fmlib_browser/index.html#val-application"><code>Fmlib_browser.application</code></a> for details.</p><p><a href="doc_single_page_application.html" title="doc_single_page_application">Writing a single-page application</a> | <a href="doc.html" title="doc">Up</a> | <a href="doc_reference_elements.html" title="doc_reference_elements">Optimizing Big Applications with Reference Elements</a></p></div></body></html>
