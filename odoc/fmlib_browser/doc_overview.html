<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>doc_overview (fmlib_browser.doc_overview)</title><meta charset="utf-8"/><link rel="stylesheet" href="../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="index.html">Up</a> – <a href="../index.html">Index</a> &#x00BB; <a href="index.html">fmlib_browser</a> &#x00BB; doc_overview</nav><header class="odoc-preamble"><h1 id="overview"><a href="#overview" class="anchor"></a>Overview</h1><p><a href="doc.html" title="doc">Up</a> <a href="doc_getting_started.html" title="doc_getting_started">Getting Started</a></p></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#basics">Basics</a></li><li><a href="#static-webpage">Static webpage</a></li><li><a href="#webpage-with-user-interaction">Webpage with user interaction</a></li><li><a href="#commands-and-subscriptions">Commands and Subscriptions</a></li><li><a href="#user-and-library-code">User and library code</a></li></ul></nav></div><div class="odoc-content"><h2 id="basics"><a href="#basics" class="anchor"></a>Basics</h2><p>The library <a href="Fmlib_browser/index.html"><code>Fmlib_browser</code></a> helps to write web applications which run in the browser in a pure functional style. It mimics the elm language in ocaml.</p><p>The core of a functional web application is a system state and the view and update functions which describe the behaviour of a web application.</p><ol><li>The <b>system state</b> contains all relevant data of the application. For a pure static page with no interaction with the user the state is just the <code>unit</code> value <code>()</code>. For an application representing a counter which can be increased or decreased by clicking on buttons the state is an <code>int</code> which represents the value of the counter. Complex applications define their own <code>state</code> record type.</li><li>A <b>view function</b> function maps the state into a virtual dom. The virtual dom is a description of what the user sees on the screen. Furthermore the virtual dom contains elements like buttons or text fields which produce messages. The messages are dispatched to the update function.</li><li>An <b>update function</b> update function maps the state of the application and a <em>message</em> to a new state. Messages are generated by the user's interaction with the web application.</li></ol><h2 id="static-webpage"><a href="#static-webpage" class="anchor"></a>Static webpage</h2><p>If we just want to display a static page with a grocery list the functions are quite simple.</p><pre class="language-ocaml"><code>    type message = |   (* no constructor,
                          i.e. no message can be created. *)

    let view (): unit Html.t =
        let open Html in
        let open Attribute in
        ol [attribute &quot;start&quot; &quot;51&quot;] [
            li [] [text &quot;Milk&quot;];
            li [] [text &quot;Honey&quot;];
            li [] [text &quot;Meet&quot;]
        ]

    let update (): message -&gt; unit =
        function
        | _ -&gt; .     (* Function can never be called because [message] has
                        no constructor *)</code></pre><p>The system state is <code>unit</code>, the <code>message</code> type has no constructors, and the <code>update</code> function, which has the type <code>state -&gt; msg -&gt; state * msg Command.t</code> (more on Commands below), cannot be called because no <code>message</code> value can ever be constructed. Thus, the only interesting part of the example is the view function. The function uses the modules <a href="Fmlib_browser/Html/index.html" title="Fmlib_browser.Html">Html</a> and <a href="Fmlib_browser/Attribute/index.html" title="Fmlib_browser.Attribute">Attribute</a> to construct the virtual dom. The virtual dom is a tree describing the displayed page. The corresponding html markup looks like</p><pre>    &lt;ol start=&quot;51&quot;&gt;
        &lt;li&gt; Milk &lt;/li&gt;
        &lt;li&gt; Honey &lt;/li&gt;
        &lt;li&gt; Meet &lt;/li&gt;
    &lt;/ol&gt;</pre><p>and the rendered page would look like</p><pre>    51. Milk
    52. Honey
    53. Meet</pre><p>The module <a href="Fmlib_browser/Html/index.html" title="Fmlib_browser.Html">Html</a> has two basic functions and a lot of abbreviations to construct a virtual dom. The two basic functions are</p><pre class="language-ocaml"><code>    text: string -&gt; 'a Html.t</code></pre><p>to construct a text node (i.e. a leaf in the virtual dom tree) and</p><pre class="language-ocaml"><code>    node: string -&gt; 'a Attribute.t list -&gt; 'a Html.t list -&gt; 'a Html.t</code></pre><p>where <code>node tag attrs children</code> constructs an element node with a tagname (div, h1, ...) a list of attributes and a list of children.</p><p>The function call <code>li [] [text &quot;Milk&quot;]</code> is just an abbreviation for</p><pre class="language-ocaml"><code>    node &quot;li&quot; [] [text &quot;Milk&quot;]</code></pre><h2 id="webpage-with-user-interaction"><a href="#webpage-with-user-interaction" class="anchor"></a>Webpage with user interaction</h2><p>A simple webpage with user interaction is a page which looks like</p><pre>    -  10 +</pre><p>where <code>-</code> and <code>+</code> are buttons which can be clicked on. Clicking on <code>-</code> decrements the counter and clicking on <code>+</code> increments it.</p><p>The following code generates such an application:</p><pre class="language-ocaml"><code>    type msg =
        | Decrement
        | Increment

    let view (counter: int): msg Html.t =
        div []
            [
              button [on_click Decrement] [text &quot;-&quot;]
            ; text (string_of_int counter)
            ; button [on_click Increment] [text &quot;+&quot;]
            ]

    let update (counter: int): msg -&gt; int = function
        | Decrement -&gt;
            counter - 1
        | Increment -&gt;
            counter + 1</code></pre><p>The corresponding html markup looks like</p><pre>    &lt;div&gt;
        &lt;button&gt; - &lt;/button&gt;
        5
        &lt;button&gt; + &lt;/button&gt;
    &lt;/div&gt;</pre><p>However the button elements get event listeners which, when pressed, either increment or decrement the state. The counter value changes on each click on one of the buttons dynamically.</p><h2 id="commands-and-subscriptions"><a href="#commands-and-subscriptions" class="anchor"></a>Commands and Subscriptions</h2><p>Practical web applications need more interactions than just mouse clicks. A web application based on <a href="Fmlib_browser/index.html"><code>Fmlib_browser</code></a> is able to</p><ul><li>send http requests</li></ul><ul><li>get the current time and the time zone</li></ul><ul><li>send and receive messages to and from the surrounding javascript</li></ul><ul><li>generate random values</li></ul><ul><li>get notifications at certain points in time</li></ul><ul><li>get notifications when the browser window is resized</li></ul><ul><li>focus and blur html elements (text input fields)</li></ul><ul><li>write to the console</li></ul><ul><li>get notifications on keyboard actions (keydown, keyup) and mouse actions (down, up, move)</li></ul><ul><li>and so much more.</li></ul><p>In order to make this possible the library <a href="Fmlib_browser/index.html"><code>Fmlib_browser</code></a> offers <a href="Fmlib_browser/Command/index.html" title="Fmlib_browser.Command">commands</a> and <a href="Fmlib_browser/Subscription/index.html" title="Fmlib_browser.Subscription">subscriptions</a>.</p><p>Commands represent a task to perform in the background, possibly terminating in a new message to pass to the application. They are typically generated via the update function. Update maps an application state and an application message to a new state and a task to perform in the background, the <code>msg Command.t</code> in its signature.</p><pre class="language-ocaml"><code>    update: state -&gt; msg -&gt; state * msg Command.t</code></pre><p>To generate notifications to the application, define the <code>subscription</code> function with the signature <code>state -&gt; msg Subscription.t</code>. This function maps the state of the app to zero or more active subscriptions.</p><pre class="language-ocaml"><code>    subscription: state -&gt; msg Subscription.t</code></pre><p>After each state change (i.e. execution of the update function) the library uses the new state and computes via the user supplied <code>subscription</code> the possibly new, changed or removed subscriptions and installs and/or removes the corresponding event listeners.</p><h2 id="user-and-library-code"><a href="#user-and-library-code" class="anchor"></a>User and library code</h2><p>All code provided by the user is and has to be purely functional. All user data like the state are immutable. The functions <code>view</code>, <code>subscription</code> and <code>update</code> must not have side effects (at least no visible side effects). The library <a href="Fmlib_browser/index.html"><code>Fmlib_browser</code></a> handles all effectful commands and mutability needed in the resulting javascript code.</p><p>The library functions hold the current user state and the current virtual dom. The library installs an event listener on the <code>requestAnimationFrame</code> event of the browser.</p><p>If the state has changed since the last animation frame then the library uses the view function to generate the corresponding virtual dom. It does a dom diffing between the new virtual dom and the stored current dom and executes the minimal actions to make the real dom look like the new virtual dom.</p><p>Since modifications of the real dom might be expensive the library tries to minimize accesses to the real dom.</p><p>The library installs the necessary event listeners on the corresponding dom elements and on all event targets which are needed to get the required notifications.</p><p>Each fired event of interest generates an object of the message type and is fed together with the state to the user supplied update function to generate a new state and an optional command.</p><p>After receiving a new state and a command from the user supplied update function the library uses the user supplied subscription function to update event listeners (if necessary) and executes the command which might produce new messages.</p><p>The new messages are dispatched to the update function on the next tick of the javascript event loop to avoid long blockings of the event loop.</p><p><a href="doc.html" title="doc">Up</a> <a href="doc_getting_started.html" title="doc_getting_started">Getting Started</a></p></div></body></html>
