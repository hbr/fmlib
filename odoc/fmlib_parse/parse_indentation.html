<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>parse_indentation (fmlib_parse.parse_indentation)</title><meta charset="utf-8"/><link rel="stylesheet" href="../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="index.html">Up</a> – <a href="../index.html">Index</a> &#x00BB; <a href="index.html">fmlib_parse</a> &#x00BB; parse_indentation</nav><header class="odoc-preamble"><h1 id="indentation-sensitivity"><a href="#indentation-sensitivity" class="anchor"></a>Indentation Sensitivity</h1><p><a href="parse.html" title="parse">Up</a></p></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#situation">Situation</a></li><li><a href="#indentation-combinators">Indentation Combinators</a><ul><li><a href="#indented-block">Indented Block</a></li><li><a href="#aligned-blocks">Aligned Blocks</a></li><li><a href="#ignore-indentation">Ignore Indentation</a></li><li><a href="#error-reporting">Error Reporting</a></li></ul></li><li><a href="#example">Example</a><ul><li><a href="#requirements">Requirements</a></li><li><a href="#yaml-structure">Yaml Structure</a></li><li><a href="#basic-combinators">Basic Combinators</a></li><li><a href="#recursive-yaml-parsing">Recursive Yaml Parsing</a></li></ul></li></ul></nav></div><div class="odoc-content"><h2 id="situation"><a href="#situation" class="anchor"></a>Situation</h2><p>Most programming languages express hierarchical structures by some kind of parentheses. Algol like languages use <code>begin</code> <code>end</code>, C like languages use curly braces <code>{</code>, <code>}</code> to enclose blocks of code. Since blocks can be nested inside blocks, the hierarchical or tree structure is well expressed by the syntax.</p><p>For the human reader blocks are usually indented to make the hierarchical structure graphically visible. Programming languages like <em>Haskell</em> and <em>Python</em> ommit the parentheses and express the hierarchical structure by indentation. I.e. the indentation is part of the grammar. This is pleasing to the eye, because many parentheses can be ommitted.</p><p>The hierarchical structure in the following schematical source file is immediately visible without the need of parentheses.</p><pre>    xxxxxxxxxxx
        xxx
        xxx
            xxxxxxx
    xxxxxxxx
        xxx</pre><p>Lower level blocks are indented with respect to their parent block and siblings at the same level are vertically aligned.</p><p>Because of this good readability configuration languages like <a href="https://yaml.org/">yaml</a> have become very popular.</p><p>Unfortunately there are not many parsers available which support indentation sensitivity. The library <a href="index.html" title="index">Fmlib_parse</a> has support to parse languages whose grammar uses indentation to structure blocks hierarchically.</p><h2 id="indentation-combinators"><a href="#indentation-combinators" class="anchor"></a>Indentation Combinators</h2><p>In order to support indentation sensitivity, all constructs parsed by combinators have a certain indentation. Usually the identation of a construct is the start column of its leftmost token. For aligned constructs the first token must be the leftmost token.</p><h3 id="indented-block"><a href="#indented-block" class="anchor"></a>Indented Block</h3><p>If <code>p</code> is a combinator parsing a certain construct, then</p><pre class="language-ocaml"><code>indent 4 p</code></pre><p>is a combinator which parses <code>p</code> indented at least <code>4</code> columns with respect to its parent.</p><h3 id="aligned-blocks"><a href="#aligned-blocks" class="anchor"></a>Aligned Blocks</h3><p>In order to align blocks vertically we need at least two combinators <code>p</code> and <code>q</code> whose constructs have to be vertically aligned.</p><p>The combinator</p><pre class="language-ocaml"><code>    (
        let* a = align p in
        let* b = align q in
        return (a, b)
    )
    |&gt; indent 4         (* Note: Indentation of the whole block is
                                 mandatory!! Never forget!! *)</code></pre><p>parses a construct with the structure</p><pre>    xxxxxx
        pppppp
        qqqqqq</pre><p>where <code>xxxxxx</code> belongs to the outer structure.</p><p>It is straightforward to parse a list of aligned constructs where the combinator <code>p</code> parses an individual item.</p><pre class="language-ocaml"><code>    one_or_more (align p) |&gt; indent 0</code></pre><p>Note that some indentation is always necessary. The indentation can be zero. If no indentation is given then the parser tries to align the items recognized by <code>p</code> vertically below the leftmost token of the surrounding construct. This is usually not intended and a common pitfall.</p><h3 id="ignore-indentation"><a href="#ignore-indentation" class="anchor"></a>Ignore Indentation</h3><p>Sometimes it is necessary to ignore the indentation. The combinator</p><pre class="language-ocaml"><code>detach p</code></pre><p>parses a construct described by the combinator <code>p</code> and ignores all indentation and alignment requirements at that position. This combinator is necessary in order to parse whitespace, because whitespace at the start of a line does not respect any indentation or alignment requirement.</p><h3 id="error-reporting"><a href="#error-reporting" class="anchor"></a>Error Reporting</h3><p>With layout parsing a syntax error can have two reasons:</p><ul><li>A token is not the expected one.</li></ul><ul><li>A token does not start at an allowed position.</li></ul><p>When a parser fails with a syntax error, it reports a list of failed expectations. Each failed expectations has two parts. A message describing the syntactic construct expected an an optional indentation expectation. If the indentation expectation is present, then the syntax error occurred because the token appeared at a not allowed position.</p><p>Because of the presence of biased choice and optional constructs in the combinators, multiple syntax expectations can fail. Therefore the parsers return a list of syntax expectations in case of a syntax error. In order make the expectations more informative for the user, it is common to use constructs like</p><pre class="language-ocaml"><code>    p &lt;/&gt; q &lt;/&gt; r &lt;?&gt; &quot;some higher level expectation&quot;</code></pre><p>The <code>&lt;?&gt;</code> works as expected with layout parsing when the operator is used inside the indent and alignment combinators. When positioned outside, the parser works correctly, but the error messages might be misleading.</p><pre class="language-ocaml"><code>    (* Correct placement of '&lt;?&gt;' *)
    p
    &lt;/&gt;
    q
    &lt;?&gt; &quot;p or q&quot;
    |&gt; align
    |&gt; one_or_more

    (* Wrong placement of '&lt;?&gt;' *)
    p
    &lt;/&gt;
    q
    |&gt; align
    &lt;?&gt; &quot;p or q&quot;
    |&gt; one_or_more</code></pre><p>If <code>p</code> and <code>q</code> fail because they are not properly aligned, their expectations are reported with the correct failed alignment expectation. In the correct sequence the operator <code>&lt;?&gt;</code> still <em>sees</em> the failed alignment and reports the more expressive expectation with the same failed alignment expectation. In the wrong sequence the <code>&lt;?&gt;</code> operator does not <em>see</em> the alignment requirement any more and reports the more expressive expectation without the failed alignment requirement.</p><h2 id="example"><a href="#example" class="anchor"></a>Example</h2><p>In this example we write a parser which parses a very simplified subset of <em>yaml</em>.</p><h3 id="requirements"><a href="#requirements" class="anchor"></a>Requirements</h3><p>Here are some examples of yaml structures and the corresponding json structure which the parser should recognize</p><pre>    Hello Mr. Spock # some comment

        json: &quot;Hello Mr. Spock&quot;

    &quot;Hello: Blabla#&quot;

        json: &quot;Hello: Blabla#&quot;

    - - - hello

        json: [[[&quot;hello&quot;]]]

    1: 11: hello
       12: &quot;&quot;
       &quot;###&quot;: hash

        json: {&quot;1&quot;: {&quot;11&quot;: &quot;hello&quot;, &quot;12&quot;: &quot;&quot;, &quot;###&quot;: &quot;hash&quot;}}

    k1:
    - 1
    - - 1.1
      - 1.2
    k2: s2

        json: {&quot;k1&quot;: [&quot;1&quot;, [&quot;1.1&quot;, &quot;1.2&quot;]], &quot;k2&quot;: &quot;s2&quot;}</pre><p>Scalars and keys in key value pairs come in two flavors. Either a sequence of characters spanning to a colon or a newline or a sequence of characters enclosed in double quotes. We don't treat escape sequences and strings in single quotes here. Here we focus on the implementation of the indentation requirements.</p><p>Note that key value pairs have to be indented, if they occur as a substructure. Lists as a value of a key value pair do not need to be indented. The <code>- </code> is sufficient to indicate the start of a list.</p><h3 id="yaml-structure"><a href="#yaml-structure" class="anchor"></a>Yaml Structure</h3><p>The final construct of the parser shall be a yaml value according to the following module:</p><pre class="language-ocaml"><code>    module Yaml =
    struct
        type t =
            | Scalar of string
            | List   of t list
            | Record of (string * t) list

        let scalar str = Scalar str

        let list lst = List lst

        let record lst = Record lst

        let rec to_json: t -&gt; string =
            (* recursive function to map a yaml value into a json string
               for testing purposes *)
    end</code></pre><h3 id="basic-combinators"><a href="#basic-combinators" class="anchor"></a>Basic Combinators</h3><p>We parse the yaml structure with the lexerless character parser.</p><pre class="language-ocaml"><code>    module CP = Character.Make (Unit) (Yaml) (Unit)
    open CP</code></pre><p>A yaml comment starts with a hash sign <code>#</code> and spans to the end of the line.</p><pre class="language-ocaml"><code>    let comment: char t =
        let* _ = char '#' in
        let* _ =
            (charp (fun c -&gt; c &lt;&gt; '\n') &quot;comment character&quot;)
            |&gt; skip_zero_or_more
        in
        return '#'</code></pre><p>Whitespace is any sequence of zero or more blanks, newlines and comments.</p><pre class="language-ocaml"><code>    let whitespace: int t =
        char ' ' &lt;/&gt; char '\n' &lt;/&gt; comment
        |&gt; skip_zero_or_more
        |&gt; no_expectations  (* no expected whitespace in syntax errors *)
        |&gt; detach           (* whitespace does not repect indentation *)


    let lexeme (p: 'a t): 'a t =
        (* Remove whitespace after 'p' *)
        let* a = p in
        let* _ = whitespace in
        return a</code></pre><p>In order to handle scalars and keys we need raw strings spanning to a colon or a newline and quoted strings.</p><pre class="language-ocaml"><code>    let raw_string: string t =
        let expect  = &quot;chars not containing colon and newline&quot; in
        let inner c = c &lt;&gt; '\n' &amp;&amp; c &lt;&gt; ':' &amp;&amp; c &lt;&gt; '#' in
        let first c = c &lt;&gt; '&quot;' &amp;&amp; inner c
        in
        (word first inner expect)
        |&gt; map String.trim
        |&gt; lexeme

    let quoted_string: string t =
        let expect = &quot;chars except newline and dquote&quot; in
        let ok c = c &lt;&gt; '\n' &amp;&amp; c &lt;&gt; '&quot;'
        in
        let* _   = char '&quot;' in
        let* str = (word ok ok expect) &lt;/&gt; return &quot;&quot; in
        let* _   = char '&quot;' |&gt; lexeme
        in
        return str

    let scalar: Yaml.t t =
        (quoted_string &lt;/&gt; raw_string)
        |&gt; map Yaml.scalar
        &lt;?&gt; &quot;scalar&quot;</code></pre><p>The start of a list element is indicated by <code>-</code>. We use the combinator <code>dash</code> to recognize the start of a list element.</p><pre class="language-ocaml"><code>    let dash: char t =
        char '-' |&gt; lexeme</code></pre><p>The key in a key value pair is either a raw string or a quoted string followed by a colon. The combinator recognizing a key has to backtrack, because a string not followed by a colon can still be a yaml scalar.</p><pre class="language-ocaml"><code>    let key: string t =
        backtrack
            (
                let* str = raw_string &lt;/&gt; quoted_string in
                let* _   = char ':' |&gt; lexeme in
                return str
            )
            &quot;&lt;key&gt;:&quot;</code></pre><h3 id="recursive-yaml-parsing"><a href="#recursive-yaml-parsing" class="anchor"></a>Recursive Yaml Parsing</h3><p>Now we have to parse recursively according to the recursive definition of a yaml structure. A yaml value is either a scalar, a sequence (i.e. list) of items or a record of key value pairs.</p><pre class="language-ocaml"><code>    let rec yaml (): Yaml.t t =
        sequence_block ()
        &lt;/&gt;
        record_block ()
        &lt;/&gt;
        scalar

    and sequence_block ...
    and record_block ...</code></pre><p>The first alternative is the sequence, because a sequence can be easily recognized by the first character <code>-</code>. If something doesn't start with a dash, then it is certainly not a sequence and the remaining alternatives can be tried.</p><p>We have to try to find a record before a scalar because a record can start with a scalar which represents the key of the first key value pair. If there is no colon after the key, then a pure scalar can be tried. Therefore we have made the combinator <code>key</code> backtrackable in order to fail without consuming any character.</p><p>A sequence block is a list of one or more aligned sequence elements. The implementation is straightforward.</p><pre class="language-ocaml"><code>    and sequence_block (): Yaml.t t =
        one_or_more
            (
                sequence_element ()
                &lt;?&gt;
                &quot;list element: \&quot;- &lt;yaml value&gt;\&quot;&quot;
                |&gt; align
            )
        |&gt; map (fun (a, lst) -&gt; Yaml.list (a :: lst))
        &lt;?&gt; &quot;sequence of aligned \&quot;- &lt;yaml value&gt;\&quot;&quot;

    and sequence_element (): Yaml.t t =
        let* _ = dash in
        yaml () |&gt; indent 1</code></pre><p>Note that all sequence elements are vertically aligned and the yaml values after the dash have to be indented at least by one column.</p><pre>        # legal sequence element            # illegal sequence element
        -                                   -
          k1: 100                           k1: 100
          k2: 200                           k2: 200</pre><p>A record block is a sequence of aligned key value pairs.</p><pre class="language-ocaml"><code>    and record_block (): Yaml.t t =
        one_or_more
            (
                record_element ()
                &lt;?&gt; &quot;\&quot;&lt;key&gt;: &lt;yaml value&gt;\&quot;&quot;
                |&gt; align
            )
        |&gt; map (fun (a, lst) -&gt; Yaml.record (a :: lst))
        &lt;?&gt; &quot;sequence of aligned \&quot;&lt;key&gt;: &lt;yaml value&gt;\&quot;&quot;

    and record_element (): (string * Yaml.t) t =
        let* str = key in
        let* y   =
            sequence_block () |&gt; indent 0
            &lt;/&gt;
            (record_block () &lt;/&gt; scalar |&gt; indent 1)
        in
        return (str, y)</code></pre><p>Note the subtlety of the indentation of sequence blocks and record blocks and scalars.</p><pre>        # legal record element              # illegal record element
        key:                                key:
        - item1                             k1: value1
        - item2                             k2: value2
</pre><p>Note furthermore that each aligned block is within some indentation (zero or more columns). <em>This is important</em>. Without some indentation the parsers try to align the elements in the block with some outer elements (which usually fails). It is a common pitfall to forget the indentation.</p><p><a href="parse.html" title="parse">Up</a></p></div></body></html>
