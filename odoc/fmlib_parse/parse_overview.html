<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>parse_overview (fmlib_parse.parse_overview)</title><meta charset="utf-8"/><link rel="stylesheet" href="../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="index.html">Up</a> â€“ <a href="../index.html">Index</a> &#x00BB; <a href="index.html">fmlib_parse</a> &#x00BB; parse_overview</nav><header class="odoc-preamble"><h1 id="overview"><a href="#overview" class="anchor"></a>Overview</h1><p><a href="parse.html" title="parse">Up</a></p></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#features">Features</a></li><li><a href="#main-modules">Main Modules</a></li><li><a href="#combinators">Combinators</a><ul><li><a href="#basic-combinators">Basic Combinators</a></li><li><a href="#sequencing">Sequencing</a></li><li><a href="#choice">Choice</a></li><li><a href="#repetition">Repetition</a></li><li><a href="#operator-expressions">Operator Expressions</a></li><li><a href="#backtracking">Backtracking</a></li><li><a href="#state">State</a></li></ul></li><li><a href="#make-a-parser">Make a Parser</a></li><li><a href="#running-the-parser-on-streams">Running the Parser on Streams</a></li></ul></nav></div><div class="odoc-content"><h2 id="features"><a href="#features" class="anchor"></a>Features</h2><p>The parsers of this library implement parsers for <i>Parsing Expression Grammars</i> with parsing combinators. They have the following main features:</p><ul><li>Like all combinator parsers (e.g. like <code>parsec</code> of Haskell) you have the full flexibility of a functional language. There is no preprocessing step where the parser has to be generated from the grammar.</li></ul><ul><li>All parsers are incremental and work in push mode. You can parse part of the input stream, look into the state of the parser. Store the parser at different locations and resume parsing at any location in the input stream.</li></ul><ul><li>It is possible to parse indentation sensitive grammars.</li></ul><p>These features in combination are to the best of our knowledge unique in <code>Fmlib_parse</code>.</p><p>Parsing expression grammars are very similar to context free grammers. There are two main differences:</p><ul><li>The choice between alternatives is biased. I.e. if parsing of the first alternative succeeds, then the next one is not parsed.</li></ul><ul><li>Left recursion is forbidden.</li></ul><p>Accepting these restrictions leads to fairly efficient parser which can be implemented directly in a functional language.</p><h2 id="main-modules"><a href="#main-modules" class="anchor"></a>Main Modules</h2><p>All parsers in this library are combinator parsers.</p><ul><li><a href="Fmlib_parse/Character/Make/index.html"><code>Fmlib_parse.Character.Make</code></a> A parser where the tokens are characters.</li></ul><ul><li><a href="Fmlib_parse/Ucharacter/index.html"><code>Fmlib_parse.Ucharacter</code></a> A parser where the tokens are unicode characters.</li></ul><ul><li><a href="Fmlib_parse/Generic/Make/index.html"><code>Fmlib_parse.Generic.Make</code></a> A generic parser where all is customizable.</li></ul><p>All parsers are functors which need some other modules to be instantiated. All parsers have to be instantiated with the following modules:</p><ul><li><code>Final</code>: The type <code>Final.t</code> is the type of the final construct which the parser returns after successful parsing.</li></ul><ul><li><code>State</code>: The type <code>State.t</code> is any type of state which the user wants to read, write or update during parsing. It can be accessed at any time. If the user does not need a state, then the module <code>Unit</code> of ocaml's standard library can be used.</li></ul><ul><li><code>Semantic</code>: During parsing the user is able to recognize semantic errors. There is a function <code>fail error</code> which let the parser fail with a semantic error with the error object of type <code>Semantic.t</code>.</li></ul><p>E.g. if you want to write a parser which parses a stream of characters then you should write a module which looks like</p><pre class="language-ocaml"><code>    module State =
    struct
        type t = ...        (* your user state *)
        ...
    end

    module Final =
    struct
        type t = ...        (* type of the final construct *)
        ...
    end

    module Semantic =
    struct
        type t = ...        (* type of semantic error *)
        ...
    end

    module Basic = Fmlib_parse.Character.Make (State) (Final) (Semantic)

    open Basic

    ...</code></pre><p>After that you write combinators starting from the basic combinators of <code>Basic</code> until you have a combinator which represents a parser for the whole input stream i.e. a combinator of type <code>Final.t Basic.t</code>. Finally you use <code>Basic.make</code> to generate the actual parser of type <code>Basic.Parser.t</code>. The next sections show how to work with combinators and how to generate the actual parser.</p><h2 id="combinators"><a href="#combinators" class="anchor"></a>Combinators</h2><p>The grammar is described by combinators. A combinator of type <code>'a t</code> returns an object of type <code>'a</code> after successful parsing.</p><h3 id="basic-combinators"><a href="#basic-combinators" class="anchor"></a>Basic Combinators</h3><p>There are the following basic combinators:</p><ul><li><code>return: 'a -&gt; 'a t</code> The combinator <code>return 5</code> immediately succeeds without consuming tokens with the value <code>5</code>.</li></ul><ul><li><code>fail: Semantic.t -&gt; 'a t</code> The combinator <code>fail &quot;Division by zero&quot;</code> immediately fails with the corresponding semantic error message (assuming <code>Semantic = String</code>).</li></ul><p>As the name implies <em>combinators</em> can be combined to form more complex combinators.</p><h3 id="sequencing"><a href="#sequencing" class="anchor"></a>Sequencing</h3><p>If we have the combinators <code>p: 'a t</code>, <code>q: 'a -&gt; 'b t</code> and <code>r: 'a -&gt; 'b -&gt; 'c t</code> and a function <code>f: 'a -&gt; 'b -&gt; 'c -&gt; 'd</code> then we can form</p><pre class="language-ocaml"><code>    let* a = p in
    let* b = q a in
    let* c = r a b in
    return (f a b c)</code></pre><p>which is a combinator of type <code>'d t</code>. This combinator describes a parser which first parses <code>p</code>. In case of success <code>p</code> returns the value <code>a</code>. Then the parser described by <code>q a</code> is exectuted which returns in case of success the value <code>b</code>. The the parser described by <code>r a b</code> is executed which returns in case of success the value <code>c</code>. Then the parser succeeds by returning <code>f a b c</code>.</p><h3 id="choice"><a href="#choice" class="anchor"></a>Choice</h3><p>In order to describe syntactic alternatives there is the choice operator <code>&lt;/&gt;: 'a t -&gt; 'a t -&gt; ' t</code>. If we have combinators <code>p: 'a t</code>, <code>q: 'a t</code> and <code>r: 'a t</code> then the combinator</p><pre class="language-ocaml"><code>    p &lt;/&gt; q &lt;/&gt; r</code></pre><p>starts by using the combinator <code>p</code>. If <code>p</code> succeeds the whole choice succeeds. If <code>p</code> fails without consuming tokens, the parsing resumes with the combinator <code>q</code>. If it succeeds then the whole choice succeeds. If <code>q</code> fails without consuming tokens, then the last combinator <code>r</code> is used.</p><p>The expression <code>p &lt;/&gt; q</code> is a <em>biased</em> choice, because the first alternative has priority. If the first alternative succeeds the next one is not tried.</p><p>If one of the alternatives in a biased choice fails after consuming some token, then the whole construct fails. Backtracking is needed (see next section) to restore consumed tokens.</p><h3 id="repetition"><a href="#repetition" class="anchor"></a>Repetition</h3><p>If you have a combinator <code>p</code> of type <code>'a t</code> which parses a certain construct, it is often necessary to parse a sequence of <em>one or more</em> or <em>zero or more</em> repetitions of the construct. All parsers have combinators to parse repetitions of a given combinator. E.g.</p><pre class="language-ocaml"><code>    list_zero_or_more p</code></pre><p>parses zero or more occurrences of the constructs parsed by <code>p</code> and returns them in a list. There are more combinators which parse repetitions like <code>one_or_more</code>, <code>skip_one_or_more</code>, <code>zero_or_more</code>, <code>one_or_more_separated</code> ... All these combinators can be found in <a href="Fmlib_parse/Interfaces/module-type-COMBINATOR/index.html"><code>Fmlib_parse.Interfaces.COMBINATOR</code></a>.</p><h3 id="operator-expressions"><a href="#operator-expressions" class="anchor"></a>Operator Expressions</h3><p>Recognizing operator expressions with unary and binary operators are a very common task for parsers. It is not very complicated to make a combinator recognizing operator expressions by using a combinator of basic combinators. However many cases can be parsed by using the combinator <a href="Fmlib_parse/Interfaces/module-type-COMBINATOR/index.html#val-operator_expression" title="Fmlib_parse.Interfaces.COMBINATOR.operator_expression">operator_expression</a>.</p><p>This combinator needs combinators to</p><ul><li>parse parentheses</li></ul><ul><li>parse unary and binary operators like <code>-</code>, <code>+</code>, <code>*</code>, ...</li></ul><ul><li>parse primary expressions</li></ul><p>Usually primary expressions are constants, identifiers or functions applied to arguments.</p><p>Furthermore combinators are needed which</p><ul><li>decide the precedence and associativity of operators</li></ul><ul><li>make unary and binary expressions from the operator and the operand(s).</li></ul><p>The <a href="parse_calculator.html" title="parse_calculator">calculator example</a> shows a simple but typical use case for this combinator.</p><h3 id="backtracking"><a href="#backtracking" class="anchor"></a>Backtracking</h3><p>Sometimes it is not possible for a combinator to fail without consuming some token. This is the case, if the first token is not sufficient to decide whether the alternative is the correct one.</p><p>In order to make such a parser fail without consuming any token it can be wrapped with the backtracking combinator. If the combinator <code>p</code> fails after consuming one or more tokens, then <code>backtrack p expect</code> fails with the expectation <code>expect</code> without consuming any token. The consumed tokens are pushed back to the lookahead and the original state is reestablished.</p><p>Backtracking has a cost because the consumed tokens have to be buffered and the original state has to be stored. The most efficient parsers do not use backtracking. However sometimes it is inevitable to backtrack.</p><h3 id="state"><a href="#state" class="anchor"></a>State</h3><p>Every parser can be instantiated with a state module. In compilers typically a symbol table is part of the state.</p><p>There are combinators to access the state during parsing. Some examples:</p><ul><li><code>get: State.t t</code> Get the state.</li></ul><ul><li><code>put: State.t -&gt; unit t</code> Set the state.</li></ul><ul><li><code>update: (State.t -&gt; State.t) -&gt; unit t</code> Update the state.</li></ul><p>E.g. a source file in a programming language consists of a sequence of definitions. After successful parsing of a definition the new definition can be added to the state with the following code:</p><pre class="language-ocaml"><code>        let* (name, def) = definition   (* parse a definition *)
        in
        update
            (State.add_definition name def)</code></pre><p>where the module <code>State</code> has a function with the signature <code>add_definition: string -&gt; definition -&gt; t -&gt; t</code>.</p><h2 id="make-a-parser"><a href="#make-a-parser" class="anchor"></a>Make a Parser</h2><p>Let's assume we have a combinator <code>c</code> with the type <code>Final.t t</code>. Then</p><pre class="language-ocaml"><code>    make state c</code></pre><p>generates a parser of type <code>Basic.Parser.t</code>. Let's assume <code>p</code> is the generated parser. Then we have the following functions to inspect the parser <code>p</code>:</p><ul><li><code>Basic.Parser.needs_more p</code>: Does the parser <code>p</code> need more tokens?</li></ul><ul><li><code>Basic.Parser.state p</code>: The state of the parser.</li></ul><ul><li><code>Basic.Parser.has_result p</code>: Has the parser <code>p</code> succeeded or failed?</li></ul><ul><li><code>Basic.Parser.has_succeeded p</code>: Has the parser <code>p</code> succeeded?</li></ul><ul><li><code>Basic.Parser.final p</code>: The final result of the parser. Requires that the parser has succeeded.</li></ul><p>In order to handle errors there are the following functions:</p><ul><li><code>Basic.Parser.has_failed_syntax p</code>: Has the parser <code>p</code> failed with a syntax error?</li></ul><ul><li><code>Basic.Parser.failed_expectations p</code>: The list of failed expectations.</li></ul><ul><li><code>Basic.Parser.has_failed_semantic p</code>: Has the parser <code>p</code> failed with a semantic error?</li></ul><ul><li><code>Basic.Parser.failed_semantic p</code>: The encountered semantic error.</li></ul><p>In order to push tokens into the parser <code>p</code> we have the function</p><pre class="language-ocaml"><code>    Basic.Parser.put token p</code></pre><p>The function returns a new parser which has either consumed the token successfully and needs more tokens or has a result (success or failure).</p><p>At the end of the token stream there is the function</p><pre class="language-ocaml"><code>    Basic.Parser.put_end p</code></pre><p>The function returns a new parser. After encountering the end, a result is available, either success or failure.</p><p>Note the inversion of control. The generated parser does not read from an input stream. Instead of reading from an input stream tokens are pushed into the parser.</p><p>Tokens can be pushed even after the parser has a result. The not needed tokens are just pushed as lookahead tokens and can be recovered by <code>Basic.Parser.lookaheads p</code>.</p><p>After signalling the end by <code>put_end p</code> to the parser, it is no longer allowed to push tokens into the parser.</p><h2 id="running-the-parser-on-streams"><a href="#running-the-parser-on-streams" class="anchor"></a>Running the Parser on Streams</h2><p>The generated parsers have inversion of control. However it is not necessary to use the inversion of control. A character parser can be run on a string or on an input channel.</p><pre class="language-ocaml"><code>    Basic.Parser.run_on_string &quot;...&quot; p

    Basic.Parser.run_channel ic p   (* 'ic' is an input channel *)</code></pre><p><a href="parse.html" title="parse">Up</a></p></div></body></html>
