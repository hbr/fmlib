<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>parse_partial (fmlib_parse.parse_partial)</title><meta charset="utf-8"/><link rel="stylesheet" href="../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="index.html">Up</a> â€“ <a href="../index.html">Index</a> &#x00BB; <a href="index.html">fmlib_parse</a> &#x00BB; parse_partial</nav><header class="odoc-preamble"><h1 id="partial-parsing"><a href="#partial-parsing" class="anchor"></a>Partial Parsing</h1><p><a href="parse.html" title="parse">Up</a></p></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#overview">Overview</a></li><li><a href="#combinators-suited-for-partial-parsing">Combinators suited for Partial Parsing</a><ul><li><a href="#complete-parsing">Complete Parsing</a></li><li><a href="#partial-parsing_2">Partial Parsing</a></li><li><a href="#a-loop-of-one-or-more">A Loop of One or More</a></li><li><a href="#a-loop-of-zero-or-more">A Loop Of Zero or More</a></li></ul></li><li><a href="#pasting-together-partial-parsers">Pasting together Partial Parsers</a><ul><li><a href="#same-types">Same Types</a></li><li><a href="#different-types">Different Types</a></li><li><a href="#parsing-with-lexers">Parsing with Lexers</a></li></ul></li></ul></nav></div><div class="odoc-content"><h2 id="overview"><a href="#overview" class="anchor"></a>Overview</h2><p>A partial parser is a parser which parses a part of the input stream and not the whole input stream until the end of input is reached. Some examples where a partial parser is useful:</p><ul><li>Convert a character input stream into a stream of tokens i.e. a lexer: A lexer usually strips off whitespace, recognizes one token (an identifier, an operator, a semicolon, ...) and in case of success returns the token even if there are more tokens to come.</li></ul><ul><li>The language to be parsed has some constructs which require to parse another file before resume parsing (e.g. the C's famous <code>#include file</code> or Ocaml's <code>open</code>. The reading of another file is I/O which cannot be done within a parsing combinator.</li></ul><ul><li>REPLs (read evaluate print loops): REPLs usually parse a construct and evaluate it immediately before parsing the next construct. The evaluation might need to do I/O which is not possible within a parsing combinator.</li></ul><p>The input stream for partial parsing might look like</p><pre>    A B C EOS</pre><p>where <code>A</code>, <code>B</code>, <code>C</code> are certain grammatical constructs and <code>EOS</code> marks the end of input. In that case we split the input stream into three different parts. The parsers parsing the constructs <code>A</code> and <code>B</code> have to be partial parsers. They can terminate successfully without consuming the end of input. Then parser for <code>C</code> is a complete parser, it terminates successfully only if followed by the end of input.</p><p>Furthermore it is possible that the input stream looks like</p><pre>    A A A ... EOS</pre><p>i.e. the stream consist of zero or more (or one or more) grammatical constructs <code>A</code>.</p><p>In order to parse <code>A*</code> i.e. zero ore more repetitions of the construct <code>A</code> we need a partial parser which parses either an <code>A</code> or the end of input.</p><p>In order to parse <code>A+</code> i.e. one or more repetitions of the construct <code>A</code> we need a partial parser which parses an <code>A</code> with an optional end of input at its end.</p><p>The structure of the stream suited for partial parsing can have arbitrary loops.</p><pre>    A B+ C* D* EOS</pre><p>But the structure must be linear. It is not possible to nest partial parsers.</p><h2 id="combinators-suited-for-partial-parsing"><a href="#combinators-suited-for-partial-parsing" class="anchor"></a>Combinators suited for Partial Parsing</h2><h3 id="complete-parsing"><a href="#complete-parsing" class="anchor"></a>Complete Parsing</h3><p>Usually you have a combinator <code>final: Final.t</code> which parses a grammatical construct <code>A</code>. If the structure of the stream is <code>A EOS</code> i.e. the structure <code>A</code> is ended by the end of input, then you make the final parser by</p><pre class="language-ocaml"><code>    make start_state final</code></pre><p>The function <code>make</code> converts a combinator and adds to it the expectation of the end of input after the construct. Therefore the parser cannot succeed unless the construct <code>A</code> fills the complete input stream to the end.</p><h3 id="partial-parsing_2"><a href="#partial-parsing_2" class="anchor"></a>Partial Parsing</h3><p>In order to make partial parser there is the function</p><pre class="language-ocaml"><code>    make_partial start_state final</code></pre><p>This function makes a partial parser parsing a grammatical construct <code>A</code> without expecting the end of input after <code>A</code>.</p><p>The function <code>make</code> is implemented by the function <code>make_partial</code> in the following way:</p><pre class="language-ocaml"><code>    let make (state: State.t) (final: Final.t t): Parser.t =
        make_partial state (final &gt;&gt;= expect_end)</code></pre><h3 id="a-loop-of-one-or-more"><a href="#a-loop-of-one-or-more" class="anchor"></a>A Loop of One or More</h3><p>Now suppose we want to write a parser which parse an input stream of the form</p><pre>    A+ EOS</pre><p>and we have a combinator <code>final: Final.t t</code> which parses a construct <code>A</code>. We construct a partial parser by</p><pre class="language-ocaml"><code>    make_partial
        state
        (
            let* a = final in
            expect_end a
            &lt;/&gt;
            return a
        )</code></pre><p>This parser parse a construct <code>A</code> followed by an optional end of input. In both cases (with or without end of input) the parser can succeed and return an object of type <code>Final.t</code>. The function <code>has_consumed_end</code> can be used to decide if the parsing has ended of if there is a next partial parser needed to parse the remainder of the input stream.</p><h3 id="a-loop-of-zero-or-more"><a href="#a-loop-of-zero-or-more" class="anchor"></a>A Loop Of Zero or More</h3><p>Now let the input stream look like</p><pre>    A* EOS</pre><p>and let <code>final: Final.t t</code> be the combinator which parses the construct <code>A</code>.</p><p>In that case we need an object <code>eos: Final.t</code> which the parser returns if the end of input has been reached. We can construct the parser by</p><pre class="language-ocaml"><code>    make_partial
        state
        (final &lt;/&gt; expect_end eos)</code></pre><p>This parser in case of success has either parsed successfully a construct <code>A</code> or has reached the end of input.</p><p>The termination of the loop can be detected either by looking at <code>has_consumed_end</code> or by comparing the final result of the parser with <code>eos</code>.</p><h2 id="pasting-together-partial-parsers"><a href="#pasting-together-partial-parsers" class="anchor"></a>Pasting together Partial Parsers</h2><h3 id="same-types"><a href="#same-types" class="anchor"></a>Same Types</h3><p>Let's assume our input stream has the structure</p><pre>    A B EOS</pre><p>and <code>pa:P.t</code> is a parser parsing <code>A</code> without consuming the end of input. Furthermore assume that <code>pa</code> has finished successfully without consuming the end of input.</p><pre class="language-ocaml"><code>    assert (P.has_succeeded pa);
    assert (not (P.has_consumed_end pa));</code></pre><p>At this point we can extract the construct representing <code>A</code> and the current state</p><pre class="language-ocaml"><code>    let state = P.state pa
    and a     = P.final pa</code></pre><p>Now we can do anything we want (make I/O etc.) using this information.</p><p>After that we want to finish parsing with the next parser. For that we need a combinator recognizing the construct <code>B</code>, say <code>b_combi</code>, and a new state (might be the same as <code>state</code>) and make a complete parser (the parser has to consume the end of input) by</p><pre class="language-ocaml"><code>    let pb = make new_state b_combi</code></pre><p>This is not yet enough, because the parser <code>pa</code> might have loaded some lookahead which is part of the construct <code>B</code>, clearly without consuming it. We have to transfer the lookahead of <code>pa</code> to <code>pb</code> by</p><pre class="language-ocaml"><code>    let pb = P.transfer_lookahead pa pb</code></pre><p>In extreme cases this might put the parser <code>pb</code> into a success state. You have to check that before continue with the parsing. If this is not yet the case i.e. the parser <code>pb</code> needs more, then you can continue the parsing.</p><h3 id="different-types"><a href="#different-types" class="anchor"></a>Different Types</h3><p>The description in the previous section only works, if the parsers <code>pa</code> and <code>pb</code> have the same type. In this section we assume that the types are different <code>pa: PA.t</code> and <code>pb: PB.t</code>. In order to transfer the lookaheads from <code>pa</code> to <code>pb</code> there is a generic function <code>fold_lookahead</code> which can be called by</p><pre class="language-ocaml"><code>    let pb = PA.fold_lookahead pb PB.put PB.put_end pa</code></pre><p>Then, as above, check if <code>pb</code> has_succeeded or failed. If it needs more tokens the parsing can continue.</p><h3 id="parsing-with-lexers"><a href="#parsing-with-lexers" class="anchor"></a>Parsing with Lexers</h3><p>For two stage parsers i.e. parsers with lexers the pasting together of subsequent parser works in principle in the same way. The user of the library only has to paste the token parser together. For details see the documentation <a href="Fmlib_parse/Parse_with_lexer/Make/index.html"><code>Fmlib_parse.Parse_with_lexer.Make</code></a></p><p><a href="parse.html" title="parse">Up</a></p></div></body></html>
