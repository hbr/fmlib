<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Make (fmlib_parse.Fmlib_parse.Ucharacter.Make)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../../index.html">Index</a> &#x00BB; <a href="../../../index.html">fmlib_parse</a> &#x00BB; <a href="../../index.html">Fmlib_parse</a> &#x00BB; <a href="../index.html">Ucharacter</a> &#x00BB; Make</nav><header class="odoc-preamble"><h1>Module <code><span>Ucharacter.Make</span></code></h1><p>Parse an input stream consisting of unicode characters. The unicode characters are encoded and decoded by using the module <code>Codec</code>.</p><ul><li><code>Codec</code>: Encoder and decoder for unicode characters</li><li><code>State</code>: User state.</li><li><code>Final</code>: Final result type of the parser.</li><li><code>Semantic</code>: Semantic error message (triggered by <code>fail error</code>)</li></ul></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#parameters">Parameters</a></li><li><a href="#signature">Signature</a><ul><li><a href="#final-parser">Final Parser</a></li><li><a href="#generic-combinators">Generic Combinators</a><ul><li><a href="#basic-combinators">Basic Combinators</a></li><li><a href="#state-combinators">State Combinators</a></li><li><a href="#optional-elements">Optional Elements</a></li><li><a href="#repetition">Repetition</a></li><li><a href="#parenthesized-expressions">Parenthesized expressions</a></li><li><a href="#operator-expressions">Operator expressions</a></li><li><a href="#backtracking">Backtracking</a></li></ul></li><li><a href="#location-combinators">Location Combinators</a></li><li><a href="#indentation-combinators">Indentation Combinators</a></li><li><a href="#end-of-input">End of Input</a></li><li><a href="#lexer-support">Lexer Support</a></li><li><a href="#character-combinators">Character Combinators</a></li><li><a href="#unicode-combinators">Unicode Combinators</a></li><li><a href="#make-the-final-parser">Make the Final Parser</a></li></ul></li></ul></nav></div><div class="odoc-content"><h2 id="parameters"><a href="#parameters" class="anchor"></a>Parameters</h2><div class="odoc-spec"><div class="spec parameter anchored" id="argument-1-Codec"><a href="#argument-1-Codec" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="argument-1-Codec/index.html">Codec</a></span><span> : <a href="../../Interfaces/module-type-CHAR_CODEC/index.html">Interfaces.CHAR_CODEC</a></span></code></div></div><div class="odoc-spec"><div class="spec parameter anchored" id="argument-2-State"><a href="#argument-2-State" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="argument-2-State/index.html">State</a></span><span> : <a href="../../../../fmlib_std/Fmlib_std/Interfaces/module-type-ANY/index.html">Fmlib_std.Interfaces.ANY</a></span></code></div></div><div class="odoc-spec"><div class="spec parameter anchored" id="argument-3-Final"><a href="#argument-3-Final" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="argument-3-Final/index.html">Final</a></span><span> : <a href="../../../../fmlib_std/Fmlib_std/Interfaces/module-type-ANY/index.html">Fmlib_std.Interfaces.ANY</a></span></code></div></div><div class="odoc-spec"><div class="spec parameter anchored" id="argument-4-Semantic"><a href="#argument-4-Semantic" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="argument-4-Semantic/index.html">Semantic</a></span><span> : <a href="../../../../fmlib_std/Fmlib_std/Interfaces/module-type-ANY/index.html">Fmlib_std.Interfaces.ANY</a></span></code></div></div><h2 id="signature"><a href="#signature" class="anchor"></a>Signature</h2><h3 id="final-parser"><a href="#final-parser" class="anchor"></a>Final Parser</h3><div class="odoc-spec"><div class="spec module anchored" id="module-Parser"><a href="#module-Parser" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Parser/index.html">Parser</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><h3 id="generic-combinators"><a href="#generic-combinators" class="anchor"></a>Generic Combinators</h3><h5 id="basic-combinators"><a href="#basic-combinators" class="anchor"></a>Basic Combinators</h5><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>_ t</span></span></code></div><div class="spec-doc"><p><code>'a t</code> Type of a parse combinator returning an <code>'a</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(&gt;&gt;=)"><a href="#val-(&gt;&gt;=)" class="anchor"></a><code><span><span class="keyword">val</span> (&gt;&gt;=) : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>p &gt;&gt;= f</code></p><p>Parse first the input according to the combinator <code>p</code>. In case of success, feed the returned value of <code>p</code> into the function <code>f</code> to get the combinator to parse next.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(let*)"><a href="#val-(let*)" class="anchor"></a><code><span><span class="keyword">val</span> (let*) : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>let* x = p in f x</code> is equivalent to <code>p &gt;&gt;= f</code></p><p>The <code>let*</code> combinator let us express parsing sequences conveniently. Example:</p><pre class="language-ocaml"><code>    let* x = p in       (* parse [p], result [x] in case of success. *)
    let* y = q x in     (* parse [q x], result [y] ... *)
    let* z = r x y in   (* ... *)
    ...
    return f x y z ...</code></pre><p>The wildcard <code>let* _ = ...</code> can be used to ignore results of intermediate parsing steps.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-map"><a href="#val-map" class="anchor"></a><code><span><span class="keyword">val</span> map : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>map f p</code></p><p>Try combinator <code>p</code>. In case of success, map the returned value <code>x</code> to <code>f x</code>. In case of failure, do nothing.</p><p><code>map f p</code> is equivalent to <code>let* x = p in return (f x)</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-map_and_update"><a href="#val-map_and_update" class="anchor"></a><code><span><span class="keyword">val</span> map_and_update : <span><span>(<span><a href="argument-2-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> * <a href="argument-2-State/index.html#type-t">State.t</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>map_and_update f p</code></p><p>Try combinator <code>p</code>. In case of success, map the returned state <code>state</code> and value <code>a</code> to <code>f state a</code>. In case of failure, do nothing.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-succeed"><a href="#val-succeed" class="anchor"></a><code><span><span class="keyword">val</span> succeed : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>succeed a</code></p><p>Succeed immediately without consuming token. Return object <code>a</code> as result.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-return"><a href="#val-return" class="anchor"></a><code><span><span class="keyword">val</span> return : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>return a</code> is equivalent to <code>succeed a</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-unexpected"><a href="#val-unexpected" class="anchor"></a><code><span><span class="keyword">val</span> unexpected : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>unexpected expect</code> triggers a syntax error signalling the expectation <code>expect</code>.</p><ul class="at-tags"><li class="deprecated"><span class="at-tag">deprecated</span> <p>Don't use this function. It will be removed in future versions.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-clear_last_expectation"><a href="#val-clear_last_expectation" class="anchor"></a><code><span><span class="keyword">val</span> clear_last_expectation : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>clear_last_expectation p</code> Clear last failed expectation.</p><p>This is useful e.g. after stripping whitespace. Since stripping whitespace means <code>skip_one_or_more ws</code> or <code>skip_zero_or_more ws</code>, after skipping whitespace the parser can still expect more whitespace. Therefore there is a failed expectation *whitespace* on the stack. However you rarely want this expectation to be reported.</p><ul class="at-tags"><li class="deprecated"><span class="at-tag">deprecated</span> <p>Use <a href="#val-no_expectations"><code>no_expectations</code></a></p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fail"><a href="#val-fail" class="anchor"></a><code><span><span class="keyword">val</span> fail : <span><a href="argument-4-Semantic/index.html#type-t">Semantic.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>fail error</code> triggers a semantic error.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(&lt;/&gt;)"><a href="#val-(&lt;/&gt;)" class="anchor"></a><code><span><span class="keyword">val</span> (&lt;/&gt;) : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>p &lt;/&gt; q</code></p><p>Try first combinator <code>p</code>. In case of success or failure with consumed token, <code>p &lt;/&gt; q</code> is equivalent to <code>p</code>.</p><p>If <code>p</code> fails without consuming token, then <code>p &lt;/&gt; q</code> is equivalent to <code>q</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-choices"><a href="#val-choices" class="anchor"></a><code><span><span class="keyword">val</span> choices : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>choices p [q r t ...]</code> is equivalent to <code>p &lt;/&gt; q &lt;/&gt; r &lt;/&gt; t &lt;/&gt; ...</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(&lt;?&gt;)"><a href="#val-(&lt;?&gt;)" class="anchor"></a><code><span><span class="keyword">val</span> (&lt;?&gt;) : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>p &lt;?&gt; expect</code></p><p>Try combinator <code>p</code>. In case of success or failure with consumed token, <code>p &lt;?&gt; expect</code> is equivalent to <code>p</code>.</p><p>If <code>p</code> fails without consuming token, then the failed expectations are replaced with the failed expectation <code>expect</code>.</p><p>Usually <code>p</code> is a combinator implementing a choice between various alternatives of a grammar construct. The <code>&lt;?&gt;</code> combinator allows to replace the set of failed grammar alternatives with a higher abstraction of the failed expectation. E.g. instead of getting the failed expectations <code>identifier</code>, <code>'('</code>, <code>-</code>, ... we can get the failed expectation <code>expression</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-no_expectations"><a href="#val-no_expectations" class="anchor"></a><code><span><span class="keyword">val</span> no_expectations : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>no_expectations p</code></p><p>Parse the combinator <code>p</code>.</p><ul><li><code>p</code> fails: <code>no_expectations p</code> fails with the same error.</li></ul><ul><li><code>p</code> succeeds without consuming tokens: <code>no_expectations p</code> succeeds without any added expectations.</li></ul><ul><li><code>p</code> succeeds and consumes some token: <code>no_expectations p</code> succeeds without any expectations.</li></ul><p>Many combinators can succeed with expectations. E.g. the combinator <a href="#val-optional" title="optional"><code>optional p</code></a> expects a <code>p</code> and succeeds if it does not encounter a construct described by <code>p</code>. All repetitive combinators like <a href="#val-one_or_more"><code>one_or_more</code></a> try to consume as many items as possible. At the end they are still expecting an item.</p><p>This combinator allows to clear such unneeded expectations. It is particularly useful when removing whitespace. The expectation of whitespace is not a meaningful error message to the user.</p></div></div><h5 id="state-combinators"><a href="#state-combinators" class="anchor"></a>State Combinators</h5><div class="odoc-spec"><div class="spec value anchored" id="val-get"><a href="#val-get" class="anchor"></a><code><span><span class="keyword">val</span> get : <span><a href="argument-2-State/index.html#type-t">State.t</a> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Get the current user state.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-set"><a href="#val-set" class="anchor"></a><code><span><span class="keyword">val</span> set : <span><a href="argument-2-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Set the user state.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-update"><a href="#val-update" class="anchor"></a><code><span><span class="keyword">val</span> update : <span><span>(<span><a href="argument-2-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="argument-2-State/index.html#type-t">State.t</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>update f</code> Update the user state using <code>f</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_and_update"><a href="#val-get_and_update" class="anchor"></a><code><span><span class="keyword">val</span> get_and_update : <span><span>(<span><a href="argument-2-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="argument-2-State/index.html#type-t">State.t</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-2-State/index.html#type-t">State.t</a> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>get_and_update f</code> Get the current user state and then update the user state. The returned value is the old state.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-state_around"><a href="#val-state_around" class="anchor"></a><code><span><span class="keyword">val</span> state_around : 
  <span><span>(<span><a href="argument-2-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="argument-2-State/index.html#type-t">State.t</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="argument-2-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-2-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="argument-2-State/index.html#type-t">State.t</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>state_around before p after</code></p><p>If <code>s0</code> is the initial state, then execute <code>p</code> with the start state <code>before s0</code> and set the update the final state <code>s1</code> by <code>after s0 a s1</code> where <code>a</code> is the returned value in case of success and <code>s1</code> is the final state after executing <code>p</code>.</p></div></div><h5 id="optional-elements"><a href="#optional-elements" class="anchor"></a>Optional Elements</h5><div class="odoc-spec"><div class="spec value anchored" id="val-optional"><a href="#val-optional" class="anchor"></a><code><span><span class="keyword">val</span> optional : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> option</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>optional p</code></p><p>Try combinator <code>p</code>.</p><ul><li>Success: Return <code>Some a</code> where <code>a</code> is the returned value.</li><li>Failure without consuming token: Return <code>None</code></li><li>Failure with consuming token: Remain in the error state.</li></ul></div></div><h5 id="repetition"><a href="#repetition" class="anchor"></a>Repetition</h5><div class="odoc-spec"><div class="spec value anchored" id="val-zero_or_more_fold_left"><a href="#val-zero_or_more_fold_left" class="anchor"></a><code><span><span class="keyword">val</span> zero_or_more_fold_left : <span><span class="type-var">'r</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'r</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'r</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'r</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>zero_or_more_fold_left start f p</code></p><p>Try the combinator <code>p</code> as often as possible. Accumulate the results to the start value <code>start</code> using the folding function <code>f</code>. The accumulation happens left to right. I.e. if 3 repetitions are encountered the folding function <code>f</code> is called</p><pre class="language-ocaml"><code>    f (f (f start a1) a2) a3</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-zero_or_more_fold_right"><a href="#val-zero_or_more_fold_right" class="anchor"></a><code><span><span class="keyword">val</span> zero_or_more_fold_right : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'r</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'r</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'r</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'r</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>zero_or_more_fold_left f p start</code></p><p>Try the combinator <code>p</code> as often as possible. Accumulate the results to the start value <code>start</code> using the folding function <code>f</code>. The accumulation happens right to left. I.e. if 3 repetitions are encountered the folding function <code>f</code> is called</p><pre class="language-ocaml"><code>    f a1 (f a2 (f a3 start))</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-one_or_more_fold_left"><a href="#val-one_or_more_fold_left" class="anchor"></a><code><span><span class="keyword">val</span> one_or_more_fold_left : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'r</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'r</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'r</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'r</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>one_or_more_fold_left first f p</code></p><p>Try the combinator <code>p</code> at least once and then as often as possible. Put the first value returned by <code>p</code> into the function <code>first</code> returning a result and accumulate the subsequent values as often as possible and accumulate the results to the start value returned by <code>first</code> using the folding function <code>f</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-zero_or_more"><a href="#val-zero_or_more" class="anchor"></a><code><span><span class="keyword">val</span> zero_or_more : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>zero_or_more p</code> Parse zero or more occurrences of <code>p</code> and return the collected result in a list.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-one_or_more"><a href="#val-one_or_more" class="anchor"></a><code><span><span class="keyword">val</span> one_or_more : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span><span class="type-var">'a</span> list</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>zero_or_more p</code> Parse one or more occurrences of <code>p</code> and return the collected results as a pair of the first value and a list of the remaining values.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-skip_zero_or_more"><a href="#val-skip_zero_or_more" class="anchor"></a><code><span><span class="keyword">val</span> skip_zero_or_more : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>int <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>skip_zero_or_more p</code> Parse zero or more occurrences of <code>p</code>, ignore the result and return the number of occurrences.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-skip_one_or_more"><a href="#val-skip_one_or_more" class="anchor"></a><code><span><span class="keyword">val</span> skip_one_or_more : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>int <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>skip_one_or_more p</code> Parse one or more occurrences of <code>p</code>, ignore the result and return the number of occurrences.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-one_or_more_separated"><a href="#val-one_or_more_separated" class="anchor"></a><code><span><span class="keyword">val</span> one_or_more_separated : 
  <span><span>(<span><span class="type-var">'item</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'r</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'r</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'sep</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'item</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'r</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'item</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'sep</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'r</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>one_or_more_separated first next p sep</code></p><p>Parse one or more occurrences of <code>p</code> separated by <code>sep</code>. Use <code>first</code> to convert the first occurrence of <code>p</code> into the result and use <code>next</code> to accumulate the results.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-counted"><a href="#val-counted" class="anchor"></a><code><span><span class="keyword">val</span> counted : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'r</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'e</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'r</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'r</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'e</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'r</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>counted min max start next p</code></p><p>Collect between <code>min</code> and <code>max</code> numbers if elements recognized by the combinator <code>p</code> and accumulate them with the folding function <code>next</code> into the start value <code>start</code>.</p></div></div><h5 id="parenthesized-expressions"><a href="#parenthesized-expressions" class="anchor"></a>Parenthesized expressions</h5><div class="odoc-spec"><div class="spec value anchored" id="val-parenthesized"><a href="#val-parenthesized" class="anchor"></a><code><span><span class="keyword">val</span> parenthesized : 
  <span><span>(<span><span class="type-var">'lpar</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'rpar</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'lpar</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'lpar</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'rpar</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>parenthesized make lpar p rpar</code></p><p>Parse an expression recognized by the combinator <code>p</code> enclosed within parentheses. <code>lpar</code> recognizes the left parenthesis and <code>rpar</code> recognizes the right parenthesis. The value returned by <code>lpar</code> is given to <code>rpar</code>. With that mechanism it is possible to recognize matching parentheses of different kinds.</p><p>After successful parsing the function <code>make</code> is called with the final value (and the parentheses).</p><p>The combinator <code>p</code> is entered as a thunk in order to be able to call it recursively. In the combinator <code>parenthesized</code> the combinator <code>p</code> is called only guardedly. Therefore the combinator <code>p</code> can contain nested parenthesized expressions.</p><p>Precondition: The combinator <code>lpar</code> has to consume at least one token in case of success.</p></div></div><h5 id="operator-expressions"><a href="#operator-expressions" class="anchor"></a>Operator expressions</h5><div class="odoc-spec"><div class="spec value anchored" id="val-operator_expression"><a href="#val-operator_expression" class="anchor"></a><code><span><span class="keyword">val</span> operator_expression : 
  <span><span><span class="type-var">'exp</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span><span class="type-var">'op</span> <a href="#type-t">t</a></span> option</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'op</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'op</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'op</span> <span class="arrow">&#45;&gt;</span></span> <span>bool <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'op</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'exp</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'exp</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'exp</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'op</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'exp</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'exp</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'exp</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><pre class="language-ocaml"><code>    operator_expression
        primary         (* Parse a primary expression *)
        unary_operator  (* Parse a unary operator *)
        binary_operator (* Parse a binary operator *)
        is_left         (* Is the left operator binding stronger? *)
        make_unary      (* Make a unary expression from the operator and
                           its operand *)
        make_binary     (* Make a binary expression from the operator
                           and its operands *)</code></pre><p>Parse an operator expression by using the following combinators:</p><ul><li><code>is_left o1 o2</code> decides, if the operator <code>o1</code> on the left has more binding power than the operator <code>o2</code>. I.e. if the unary operator <code>u</code> has more binding power than the binary operator <code>o</code>, then <code>u a o b</code> is parsed as <code>(u a) o b</code>. If the binary operator <code>o1</code> has more binding power than the binary operator <code>o2</code>, then <code>a o1 b o2 b</code> is parsed as <code>(a o1 b) o2 c</code>.</li></ul><ul><li><code>make_unary u a</code> makes the unary expression <code>(u a)</code>.</li></ul><ul><li><code>make_binary a o b</code> makes the binary expression <code>(a o b)</code>.</li></ul><ul><li><code>primary</code> parses a primary expression.</li></ul><ul><li><code>unary_operator</code> parses a unary operator.</li></ul><ul><li><code>binary_operator</code> parses a binary operator.</li></ul><p>Precondition: <code>primary</code>, <code>unary_operator</code> and <code>binary_operator</code> have to consume at least one token in case of success. Otherwise infinite recursion can happen.</p></div></div><h5 id="backtracking"><a href="#backtracking" class="anchor"></a>Backtracking</h5><div class="odoc-spec"><div class="spec value anchored" id="val-backtrack"><a href="#val-backtrack" class="anchor"></a><code><span><span class="keyword">val</span> backtrack : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>backtrack p expect</code></p><p>Try the combinator <code>p</code>. In case of failure with consuming token, push the consumed token back to the lookahead and let it fail without consuming token. Use <code>expect</code> to record the failed expectation.</p><p>Backtracking reduces the performance, because the token pushed back to the lookahead have to be parsed again. Try to avoid backtracking whenever possible.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-followed_by"><a href="#val-followed_by" class="anchor"></a><code><span><span class="keyword">val</span> followed_by : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>followed_by p expect</code></p><p>Parses <code>p</code> and backtracks (i.e. all tokens of <code>p</code> will be pushed back to the lookahead). In case <code>p</code> succeeds, the <code>followed_by</code> parser succeeds without consuming token. Otherwise it fails without consuming tokens.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-not_followed_by"><a href="#val-not_followed_by" class="anchor"></a><code><span><span class="keyword">val</span> not_followed_by : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>not_followed_by p expect</code></p><p>Parses <code>p</code> and backtracks (i.e. all tokens of <code>p</code> will be pushed back to the lookahead). In case <code>p</code> succeeds, the <code>not_followed_by</code> parser fails without consuming token. Otherwise it succeeds without consuming tokens.</p></div></div><p><code>followed_by</code> and <code>not_followed_by</code> can be used to peek into the token stream without consuming token.</p><h3 id="location-combinators"><a href="#location-combinators" class="anchor"></a>Location Combinators</h3><div class="odoc-spec"><div class="spec value anchored" id="val-located"><a href="#val-located" class="anchor"></a><code><span><span class="keyword">val</span> located : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="../../Located/index.html#type-t">Located.t</a></span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>located p</code> Parse <code>p</code> and return its result with its start and end position.</p><p>Note: If <code>p</code> removes whitespace at the end, the returned end position is at the end of the whitespace. This is not what you usually want. Therefore first parse the essential part located and then remove the whitespace.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-position"><a href="#val-position" class="anchor"></a><code><span><span class="keyword">val</span> position : <span><a href="../../Position/index.html#type-t">Position.t</a> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>The current position in the file.</p></div></div><h3 id="indentation-combinators"><a href="#indentation-combinators" class="anchor"></a>Indentation Combinators</h3><p>The indentation of a normal construct is the indentation of its leftmost token. The indentation of a vertically aligned construct is the indentation of its first token.</p><div class="odoc-spec"><div class="spec value anchored" id="val-indent"><a href="#val-indent" class="anchor"></a><code><span><span class="keyword">val</span> indent : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>indent i p</code> Indent <code>p</code> by <code>i</code> columns relative to its parent.</p><p>Precondition: <code>0 &lt;= i</code></p><p>The indentation of <code>p</code> is defined by the indentation of its first token. The first token has to be indented at least <code>i</code> columns relative to the parent of <code>p</code>. After the first token of <code>p</code> has been parsed successfully, all subsequent tokens must have at least the same indentation.</p><p>Note: Indentation of <code>p</code> relative to its parent only makes sense, if the first token of <code>p</code> is not the first token of its parent! I.e. the parent of <code>p</code> should have consumed at least one token before the parsing of <code>p</code> starts.</p></div></div><p>CAUTION WITH ALIGNMENT !!</p><p>If you want to align a certain number of constructs vertically it is <em>mandatory</em> to indent the whole block of constructs. Do not indent the individual items to be aligned. Indent the whole block.</p><p>Reason: The parent of the block usually has already consumed some token and the indentation of a construct is the position of the leftmost token. If you don't indent the aligned block, then it will be aligned with the leftmost token of the parent construct. This is usually not intended and a common pitfall. Any indentation e.g. zero indentation is ok.</p><div class="odoc-spec"><div class="spec value anchored" id="val-align"><a href="#val-align" class="anchor"></a><code><span><span class="keyword">val</span> align : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>align p</code></p><p>Use the start position of the first token of <code>p</code> to align it with other constructs. If <code>p</code> does not consume any token, then <code>align p</code> has no effect.</p><p>Alignment makes sense if there are at least two combinators which are aligned and indented. E.g. suppose there are two combinators <code>p</code> and <code>q</code>. Then we can form</p><pre class="language-ocaml"><code>indent 1 (
        let* a = align p in
        let* b = align q in
        return (a,b)
)</code></pre><p>This combinator parses <code>p</code> whose first token has to be indented at least one column relative to its parent. And then it parses <code>q</code> whose first token must be aligned with the first token of <code>p</code>.</p><p>The indentation decouples the alignment of <code>p</code> and <code>q</code> with other aligned siblings or parents. <code>indent 0 ...</code> can be used to make the indentation optional.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-left_align"><a href="#val-left_align" class="anchor"></a><code><span><span class="keyword">val</span> left_align : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>left_align p</code></p><p>Align a construct described by <code>p</code> at its leftmost possible column. If a whole block of constructs have to be vertically left aligned, then it is important that at least the first construct is left aligned. The subsequent constructs will be aligned exactly vertically. For the subsequent constructs <code>left_align</code> has the same effect as <a href="#val-align"><code>align</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-detach"><a href="#val-detach" class="anchor"></a><code><span><span class="keyword">val</span> detach : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>detach p</code> Parse <code>p</code> without any indentation and alignment restrictions.</p><p>Detachment is needed to parse whitespace. The whitespace at the beginning of a line never satisfies any nontrivial indentation or aligment requirements.</p></div></div><h3 id="end-of-input"><a href="#end-of-input" class="anchor"></a>End of Input</h3><div class="odoc-spec"><div class="spec value anchored" id="val-expect_end"><a href="#val-expect_end" class="anchor"></a><code><span><span class="keyword">val</span> expect_end : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>expect_end a</code> Expect the end of token stream.</p><p>In case of success return <code>a</code>.</p><p>In case of failure return the syntax error with the expectation &quot;end of input&quot;.</p><p><b>CAUTION</b>: There is usually no need to use this combinator! This combinator is needed only for partial parsers.</p><p><b>Never ever</b> backtrack over this combinator.</p></div></div><h3 id="lexer-support"><a href="#lexer-support" class="anchor"></a>Lexer Support</h3><div class="odoc-spec"><div class="spec value anchored" id="val-lexer"><a href="#val-lexer" class="anchor"></a><code><span><span class="keyword">val</span> lexer : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'tok</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'tok</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="../../Position/index.html#type-range">Position.range</a> * <span class="type-var">'tok</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>lexer whitespace end_token tok</code></p><p>A lexer combinator.</p><ul><li>The <code>whitespace</code> combinator recognizes a possibly empty sequence of whitespace (usually blanks, tabs, newlines, comments, ...).</li></ul><ul><li><code>end_token</code> is a token which the lexer returns when it has successfully consumed the end of input.</li></ul><ul><li><code>tok</code> is a combinator recognizing tokens (usually <code>tok1 &lt;/&gt; tok2 &lt;/&gt; ... &lt;/&gt; tokn</code>).</li></ul><p>The lexer combinator recognizes tokens in an input stream of the form</p><pre>   WS Token WS Token .... WS EOF</pre><p>Note: If a combinator fails to recognize a token and having consumed some input, then the subsequent combinators are not used anymore as alternatives. Therefore if there are tokens which can begin with the same prefix, then it is necessary to make the recognition of the common prefixes backtrackable in all but the last combinator recognizing a token with the same prefix. The same applies to whitespace if part of the whitespace can begin like a token.</p><p>Examples:</p><ul><li>comment: &quot;// ....&quot;</li><li>division operator: &quot;/&quot;</li></ul><p>In this case the recognition at least of the first slash of the comment has to be backtrackable.</p></div></div><h3 id="character-combinators"><a href="#character-combinators" class="anchor"></a>Character Combinators</h3><div class="odoc-spec"><div class="spec value anchored" id="val-charp"><a href="#val-charp" class="anchor"></a><code><span><span class="keyword">val</span> charp : <span><span>(<span>char <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>char <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>charp p expect</code> Parse a character which satisfies the predicate <code>p</code>.</p><p>In case of failure, report the failed expectation <code>expect</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-range"><a href="#val-range" class="anchor"></a><code><span><span class="keyword">val</span> range : <span>char <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> <span>char <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>range c1 c2</code> Parses a character in the range between <code>c1</code> and <code>c2</code>, i.e. a character <code>c</code> which satisfies <code>c1 &lt;= c &amp;&amp; c &lt;= c2</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-char"><a href="#val-char" class="anchor"></a><code><span><span class="keyword">val</span> char : <span>char <span class="arrow">&#45;&gt;</span></span> <span>char <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>char c</code> Parse the character <code>c</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-one_of_chars"><a href="#val-one_of_chars" class="anchor"></a><code><span><span class="keyword">val</span> one_of_chars : <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>char <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>one_of_chars str expect</code></p><p>Parse one of the characters in the string <code>str</code>. In case of failure, report the failed expectation <code>expect</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-string"><a href="#val-string" class="anchor"></a><code><span><span class="keyword">val</span> string : <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>string str</code> Parse the string <code>str</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-uppercase_letter"><a href="#val-uppercase_letter" class="anchor"></a><code><span><span class="keyword">val</span> uppercase_letter : <span>char <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Parse an uppercase letter.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-lowercase_letter"><a href="#val-lowercase_letter" class="anchor"></a><code><span><span class="keyword">val</span> lowercase_letter : <span>char <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Parse a lowercase letter.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-letter"><a href="#val-letter" class="anchor"></a><code><span><span class="keyword">val</span> letter : <span>char <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Parse a letter.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-digit_char"><a href="#val-digit_char" class="anchor"></a><code><span><span class="keyword">val</span> digit_char : <span>char <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Parse a digit <code>0..9</code> and return it as character.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-digit"><a href="#val-digit" class="anchor"></a><code><span><span class="keyword">val</span> digit : <span>int <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Parse a digit and return it as number.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-word"><a href="#val-word" class="anchor"></a><code><span><span class="keyword">val</span> word : <span><span>(<span>char <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>char <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>word first inner error</code></p><p>Parse a word which starts with a character satisfying the predicate <code>first</code> followed by zero or more characters satisfying the predicate <code>inner</code>. In case of failure add the expectation <code>error</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-hex_uppercase"><a href="#val-hex_uppercase" class="anchor"></a><code><span><span class="keyword">val</span> hex_uppercase : <span>int <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Equivalent to <code>range 'A' 'F'</code> and then converted to the corresponding number between <code>10</code> and <code>15</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-hex_lowercase"><a href="#val-hex_lowercase" class="anchor"></a><code><span><span class="keyword">val</span> hex_lowercase : <span>int <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Equivalent to <code>range 'a' 'f'</code> and then converted to the corresponding number between <code>10</code> and <code>15</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-hex_digit"><a href="#val-hex_digit" class="anchor"></a><code><span><span class="keyword">val</span> hex_digit : <span>int <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Parse a hexadecimal digit and return the corresponding number between <code>0</code> and <code>15</code>.</p></div></div><h3 id="unicode-combinators"><a href="#unicode-combinators" class="anchor"></a>Unicode Combinators</h3><div class="odoc-spec"><div class="spec value anchored" id="val-uchar"><a href="#val-uchar" class="anchor"></a><code><span><span class="keyword">val</span> uchar : <span><span class="xref-unresolved">Stdlib</span>.Uchar.t <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Stdlib</span>.Uchar.t <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>uchar uc</code> Parse the unicode character <code>uc</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ucharp"><a href="#val-ucharp" class="anchor"></a><code><span><span class="keyword">val</span> ucharp : <span><span>(<span><span class="xref-unresolved">Stdlib</span>.Uchar.t <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Stdlib</span>.Uchar.t <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>ucharp p error</code></p><p>Parse a unicode character which satisfies the predicate <code>p</code>. If the next character does not satisfy the predicate, then use the string <code>error</code> to express the failed expectation.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-urange"><a href="#val-urange" class="anchor"></a><code><span><span class="keyword">val</span> urange : <span><span class="xref-unresolved">Stdlib</span>.Uchar.t <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Stdlib</span>.Uchar.t <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Stdlib</span>.Uchar.t <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>urange uc1 uc2</code></p><p>Parse a unicode character whose scalar value is in the range between the scalar values of <code>uc1</code> and <code>uc2</code> including the boundaries.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-uword"><a href="#val-uword" class="anchor"></a><code><span><span class="keyword">val</span> uword : 
  <span><span>(<span><span class="xref-unresolved">Stdlib</span>.Uchar.t <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="xref-unresolved">Stdlib</span>.Uchar.t <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span>string <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>uword first inner error</code></p><p>Parse a sequence of unicode characters whose first character satisfies the predicate <code>first</code> and all subsequence characters satisfy the predicate <code>inner</code>. If no such word is encountered then use the string <code>error</code> to express the expectation.</p></div></div><h3 id="make-the-final-parser"><a href="#make-the-final-parser" class="anchor"></a>Make the Final Parser</h3><div class="odoc-spec"><div class="spec value anchored" id="val-make"><a href="#val-make" class="anchor"></a><code><span><span class="keyword">val</span> make : <span><a href="argument-2-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="argument-3-Final/index.html#type-t">Final.t</a> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="Parser/index.html#type-t">Parser.t</a></span></code></div><div class="spec-doc"><p><code>make state c</code></p><p>Make a parser which starts in state <code>state</code> and parses a construct defined by the combinator <code>c</code>. The token stream must be ended by <code>put_end</code>, otherwise the parse won't succeed.</p><p><b>CAUTION</b>: <code>c</code> must not be a combinator containing <code>expect_end</code>. Moreover it must not have been constructed by <a href="#val-lexer"><code>lexer</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-make_partial"><a href="#val-make_partial" class="anchor"></a><code><span><span class="keyword">val</span> make_partial : <span><a href="../../Position/index.html#type-t">Position.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-2-State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="argument-3-Final/index.html#type-t">Final.t</a> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="Parser/index.html#type-t">Parser.t</a></span></code></div><div class="spec-doc"><p><code>make_partial pos state c</code></p><p>Make parser which analyzes a part of the input stream. The parser starts at position <code>pos</code> in state <code>state</code> and parses a construct defined by the combinator <code>c</code>. The parser can succeed even if no end token has been pushed into the parser.</p></div></div></div></body></html>
