<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Make (fmlib_parse.Fmlib_parse.Parse_with_lexer.Make)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../../index.html">Index</a> &#x00BB; <a href="../../../index.html">fmlib_parse</a> &#x00BB; <a href="../../index.html">Fmlib_parse</a> &#x00BB; <a href="../index.html">Parse_with_lexer</a> &#x00BB; Make</nav><header class="odoc-preamble"><h1>Module <code><span>Parse_with_lexer.Make</span></code></h1><p>Generate a parser with a lexer and a token parser.</p><p>The generated parser parses a stream of characters. The lexer is used to convert the stream of characters into a stream of tokens of type <code>Position.range * Token.t</code> which are fed into the token parser.</p><p>The type of tokens is char.</p><pre class="language-ocaml"><code>    type token = char</code></pre><p>Type of syntax expectations:</p><pre class="language-ocaml"><code>    type expect = string * Indent.expectation option</code></pre></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#parameters">Parameters</a></li><li><a href="#signature">Signature</a><ul><li><a href="#feeding-tokens">Feeding Tokens</a></li><li><a href="#success">Success</a></li><li><a href="#syntax-errors">Syntax Errors</a></li><li><a href="#semantic-errors">Semantic Errors</a></li><li><a href="#state">State</a></li><li><a href="#lexer-and-parser">Lexer and Parser</a></li><li><a href="#partial-parser">Partial Parser</a></li><li><a href="#position">Position</a></li><li><a href="#run-the-parser">Run the Parser</a></li></ul></li></ul></nav></div><div class="odoc-content"><h2 id="parameters"><a href="#parameters" class="anchor"></a>Parameters</h2><div class="odoc-spec"><div class="spec parameter anchored" id="argument-1-State"><a href="#argument-1-State" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="argument-1-State/index.html">State</a></span><span> : <a href="../../../../fmlib_std/Fmlib_std/Interfaces/module-type-ANY/index.html">ANY</a></span></code></div></div><div class="odoc-spec"><div class="spec parameter anchored" id="argument-2-Token"><a href="#argument-2-Token" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="argument-2-Token/index.html">Token</a></span><span> : <a href="../../../../fmlib_std/Fmlib_std/Interfaces/module-type-ANY/index.html">ANY</a></span></code></div></div><div class="odoc-spec"><div class="spec parameter anchored" id="argument-3-Final"><a href="#argument-3-Final" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="argument-3-Final/index.html">Final</a></span><span> : <a href="../../../../fmlib_std/Fmlib_std/Interfaces/module-type-ANY/index.html">ANY</a></span></code></div></div><div class="odoc-spec"><div class="spec parameter anchored" id="argument-4-Semantic"><a href="#argument-4-Semantic" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="argument-4-Semantic/index.html">Semantic</a></span><span> : <a href="../../../../fmlib_std/Fmlib_std/Interfaces/module-type-ANY/index.html">ANY</a></span></code></div></div><div class="odoc-spec"><div class="spec parameter anchored" id="argument-5-Lex"><a href="#argument-5-Lex" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="argument-5-Lex/index.html">Lex</a></span><span> : 
  <a href="../../Interfaces/module-type-LEXER/index.html">Interfaces.LEXER</a>
    <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="../../Interfaces/module-type-LEXER/index.html#type-final">final</a> = <a href="../../Position/index.html#type-range">Position.range</a> * <a href="argument-2-Token/index.html#type-t">Token.t</a></span>
     <span class="keyword">and</span> <span><span class="keyword">type</span> <a href="../../Interfaces/module-type-LEXER/index.html#type-token">token</a> = char</span></span></code></div></div><div class="odoc-spec"><div class="spec parameter anchored" id="argument-6-Parse"><a href="#argument-6-Parse" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="argument-6-Parse/index.html">Parse</a></span><span> : 
  <a href="../../Interfaces/module-type-FULL_PARSER/index.html">Interfaces.FULL_PARSER</a>
    <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="../../Interfaces/module-type-FULL_PARSER/index.html#type-state">state</a> = <a href="argument-1-State/index.html#type-t">State.t</a></span>
     <span class="keyword">and</span> <span><span class="keyword">type</span> <a href="../../Interfaces/module-type-FULL_PARSER/index.html#type-token">token</a> = <a href="../../Position/index.html#type-range">Position.range</a> * <a href="argument-2-Token/index.html#type-t">Token.t</a></span>
     <span class="keyword">and</span> <span><span class="keyword">type</span> <a href="../../Interfaces/module-type-FULL_PARSER/index.html#type-expect">expect</a> = string * <span><a href="../../Indent/index.html#type-expectation">Indent.expectation</a> option</span></span>
     <span class="keyword">and</span> <span><span class="keyword">type</span> <a href="../../Interfaces/module-type-FULL_PARSER/index.html#type-final">final</a> = <a href="argument-3-Final/index.html#type-t">Final.t</a></span>
     <span class="keyword">and</span> <span><span class="keyword">type</span> <a href="../../Interfaces/module-type-FULL_PARSER/index.html#type-semantic">semantic</a> = <a href="argument-4-Semantic/index.html#type-t">Semantic.t</a></span></span></code></div></div><h2 id="signature"><a href="#signature" class="anchor"></a>Signature</h2><p>A parser <code>p</code> is a sink of token. As long as it signals <code>needs_more p</code> more token can be pushed into the parser via <code>put token p</code> or the input stream can be ended via <code>put_end p</code>.</p><p><code>has_ended  p</code> is equivalent to <code>not (needs_more p)</code>. <code>has_ended  p</code> signals that the parser has either succeeded or failed.</p><p>If it has succeeded the final value is available via <code>final p</code>.</p><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div><div class="spec-doc"><p>Type of the parser.</p></div></div><h3 id="feeding-tokens"><a href="#feeding-tokens" class="anchor"></a>Feeding Tokens</h3><div class="odoc-spec"><div class="spec type anchored" id="type-token"><a href="#type-token" class="anchor"></a><code><span><span class="keyword">type</span> token</span><span> = char</span></code></div><div class="spec-doc"><p>Type of the tokens.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-item"><a href="#type-item" class="anchor"></a><code><span><span class="keyword">type</span> item</span><span> = <a href="#type-token">token</a></span></code></div><div class="spec-doc"><p>In order to conform to the interface <a href="../../../../fmlib_std/Fmlib_std/Interfaces/module-type-SINK/index.html"><code>Fmlib_std.Interfaces.SINK</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-needs_more"><a href="#val-needs_more" class="anchor"></a><code><span><span class="keyword">val</span> needs_more : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>needs_more p</code> Does the parser <code>p</code> need more tokens?</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-put"><a href="#val-put" class="anchor"></a><code><span><span class="keyword">val</span> put : <span><a href="#type-token">token</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>put tok p</code> Push token <code>tok</code> into the parser <code>p</code>.</p><p>Even if the parser has ended, more tokens can be pushed into the parser. The parser stores the token as lookahead token.</p><p>If the parser has already received the end of the token stream via <a href="#val-put_end"><code>put_end</code></a>, then all subsequent tokens are ignored.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-put_end"><a href="#val-put_end" class="anchor"></a><code><span><span class="keyword">val</span> put_end : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>put_end p</code> Push and end token into the parser <code>p</code>.</p></div></div><h3 id="success"><a href="#success" class="anchor"></a>Success</h3><div class="odoc-spec"><div class="spec type anchored" id="type-final"><a href="#type-final" class="anchor"></a><code><span><span class="keyword">type</span> final</span><span> = <a href="argument-3-Final/index.html#type-t">Final.t</a></span></code></div><div class="spec-doc"><p>Type of the final result.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-has_succeeded"><a href="#val-has_succeeded" class="anchor"></a><code><span><span class="keyword">val</span> has_succeeded : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>has_succeeded p</code> Has the parser <code>p</code> succeeded?</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-has_ended"><a href="#val-has_ended" class="anchor"></a><code><span><span class="keyword">val</span> has_ended : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>has_ended p</code> Has the parser <code>p</code> ended parsing and either succeeded or failed?</p><p><code>has_ended p</code> is the same as <code>not (needs_more p)</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-has_consumed_end"><a href="#val-has_consumed_end" class="anchor"></a><code><span><span class="keyword">val</span> has_consumed_end : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Has the parser consumed the end of input?</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-final"><a href="#val-final" class="anchor"></a><code><span><span class="keyword">val</span> final : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-final">final</a></span></code></div><div class="spec-doc"><p><code>final p</code> The final object constructed by the parser <code>p</code> in case of success.</p><p>Precondition: <code>has_succeeded p</code></p></div></div><h3 id="syntax-errors"><a href="#syntax-errors" class="anchor"></a>Syntax Errors</h3><div class="odoc-spec"><div class="spec type anchored" id="type-expect"><a href="#type-expect" class="anchor"></a><code><span><span class="keyword">type</span> expect</span><span> = string * <span><a href="../../Indent/index.html#type-expectation">Indent.expectation</a> option</span></span></code></div><div class="spec-doc"><p>Type of expectations.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-has_failed_syntax"><a href="#val-has_failed_syntax" class="anchor"></a><code><span><span class="keyword">val</span> has_failed_syntax : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>has_failed_syntax p</code> Has the parser <code>p</code> failed with a syntax error?</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-failed_expectations"><a href="#val-failed_expectations" class="anchor"></a><code><span><span class="keyword">val</span> failed_expectations : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-expect">expect</a> list</span></span></code></div><div class="spec-doc"><p><code>failed_expectations p</code> The failed expectations due to a syntax error.</p><p>Precondition: <code>has_failed_syntax p</code></p></div></div><h3 id="semantic-errors"><a href="#semantic-errors" class="anchor"></a>Semantic Errors</h3><div class="odoc-spec"><div class="spec type anchored" id="type-semantic"><a href="#type-semantic" class="anchor"></a><code><span><span class="keyword">type</span> semantic</span><span> = <a href="argument-4-Semantic/index.html#type-t">Semantic.t</a></span></code></div><div class="spec-doc"><p>Type of semantic errors.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-has_failed_semantic"><a href="#val-has_failed_semantic" class="anchor"></a><code><span><span class="keyword">val</span> has_failed_semantic : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Has the parser failed because of a semantic error?</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-failed_semantic"><a href="#val-failed_semantic" class="anchor"></a><code><span><span class="keyword">val</span> failed_semantic : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-semantic">semantic</a></span></code></div><div class="spec-doc"><p>The semantic error encountered.</p><p>Precondition: A semantic error has occurred.</p></div></div><h3 id="state"><a href="#state" class="anchor"></a>State</h3><div class="odoc-spec"><div class="spec type anchored" id="type-state"><a href="#type-state" class="anchor"></a><code><span><span class="keyword">type</span> state</span><span> = <a href="argument-1-State/index.html#type-t">State.t</a></span></code></div><div class="spec-doc"><p>Type of the state of the parser (in many cases <code>unit</code>)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-state"><a href="#val-state" class="anchor"></a><code><span><span class="keyword">val</span> state : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-state">state</a></span></code></div><div class="spec-doc"><p>The state of the parser.</p></div></div><h3 id="lexer-and-parser"><a href="#lexer-and-parser" class="anchor"></a>Lexer and Parser</h3><div class="odoc-spec"><div class="spec value anchored" id="val-make"><a href="#val-make" class="anchor"></a><code><span><span class="keyword">val</span> make : <span><a href="argument-5-Lex/index.html#type-t">Lex.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-6-Parse/index.html#type-t">Parse.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>make lex parse</code> Make the parser from a lexer and a parser.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-lex"><a href="#val-lex" class="anchor"></a><code><span><span class="keyword">val</span> lex : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="argument-5-Lex/index.html#type-t">Lex.t</a></span></code></div><div class="spec-doc"><p>The lexer part of the parser.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-parse"><a href="#val-parse" class="anchor"></a><code><span><span class="keyword">val</span> parse : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="argument-6-Parse/index.html#type-t">Parse.t</a></span></code></div><div class="spec-doc"><p>The parser part of the parser.</p></div></div><h3 id="partial-parser"><a href="#partial-parser" class="anchor"></a>Partial Parser</h3><p>If the input stream shall be parsed in parts, then a parser with a lexer can be used for partial parsing as well.</p><p>Note that the lexer must be partial, because it succeeds after successfully parsing a lexical token from the input stream and is restarted afterwards. The restart of the lexer transfers the lookahead from the previous lexer to the next lexer.</p><p>A parser with a lexer becomes partial, if the token parser is partial. As user of this module you have to transfer only the lookahead buffer from the old token parser to the next token parser.</p><p>If the old and the new token parser have the same type, then the function <a href="#val-make_next"><code>make_next</code></a> can be used to transfer the lookahead buffer.</p><p>If the old and the new token parser have different types then the following will do the job. Assume that <code>TP1.t</code> and <code>TP2.t</code> are the types of the old and new token parser, <code>P1.t</code> and <code>P2.t</code> are the types of the corresponding parsers with lexers and <code>tp2: TP2.t</code> is the new token parser</p><pre class="language-ocaml"><code>    assert (P1.has_succeeded p1);
    assert (not (P1. has_consumed_end p1));
    let lex = P1.lex p1
    and tp1 = P1.parse p1
    in
    let tp2 = TP2.fold_lookahead tp2 TP2.put TP2.put_end tp1 in
    let p2  = P2.make lex tp2 in
    ...</code></pre><p>Note that as described in the chapter <a href="../../../parse_partial.html" title="parse_partial">Partial Parsing</a> the parser <code>p2</code> might have used the lookaheads of <code>p1</code> to either succeed or fail. You can continue parsing the input stream only of this is not yet the case. Otherwise you might need a new subsequent token parser to continue to parse the remaining input stream.</p><div class="odoc-spec"><div class="spec value anchored" id="val-make_next"><a href="#val-make_next" class="anchor"></a><code><span><span class="keyword">val</span> make_next : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="argument-6-Parse/index.html#type-t">Parse.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>make_next p tp</code></p><p>This function assumes that <code>p</code> has been made with a partial token parser and has already successfully consumed a part of the input stream and <code>tp</code> is the token parser which shall be used to parse the next part of the input stream.</p><p>Since the token parser contained in <code>p</code> might have unconsumed lookahead tokens, these tokens must be transferred to the new token parser <code>tp</code>.</p><p>The call <code>make_next p tp</code> makes a new parser with lexer using the old lexer and the new token parser <code>tp</code> with all the lookaheads transferred to it.</p></div></div><h3 id="position"><a href="#position" class="anchor"></a>Position</h3><div class="odoc-spec"><div class="spec value anchored" id="val-position"><a href="#val-position" class="anchor"></a><code><span><span class="keyword">val</span> position : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../Position/index.html#type-t">Position.t</a></span></code></div><div class="spec-doc"><p>The current position in the input.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-range"><a href="#val-range" class="anchor"></a><code><span><span class="keyword">val</span> range : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../Position/index.html#type-range">Position.range</a></span></code></div><div class="spec-doc"><p>The current range in the input; usually the range of the first lookahead token. In case of a syntax error this is the unexpected token i.e. the token which caused the syntax error.</p></div></div><h3 id="run-the-parser"><a href="#run-the-parser" class="anchor"></a>Run the Parser</h3><div class="odoc-spec"><div class="spec value anchored" id="val-run_on_string"><a href="#val-run_on_string" class="anchor"></a><code><span><span class="keyword">val</span> run_on_string : <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>run_on_string str p</code> Run the parser <code>p</code> on the string <code>str</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-run_on_string_at"><a href="#val-run_on_string_at" class="anchor"></a><code><span><span class="keyword">val</span> run_on_string_at : <span>int <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int * <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>run_on_string str start p</code> Run the parser <code>p</code> on the string <code>str</code> starting at index <code>start</code> Return the parser and the index next to be pushed in.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-run_on_channel"><a href="#val-run_on_channel" class="anchor"></a><code><span><span class="keyword">val</span> run_on_channel : <span><span class="xref-unresolved">Stdlib</span>.in_channel <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>run_on_channel ch p</code> Run the parser <code>p</code> on the channel <code>ch</code>.</p></div></div></div></body></html>
