<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>COMBINATOR_WITH_POSITION (fmlib_parse.Fmlib_parse.Interfaces.COMBINATOR_WITH_POSITION)</title><link rel="stylesheet" href="../../../../odoc.support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">fmlib_parse</a> &#x00BB; <a href="../../index.html">Fmlib_parse</a> &#x00BB; <a href="../index.html">Interfaces</a> &#x00BB; COMBINATOR_WITH_POSITION</nav><header class="odoc-preamble"><h1>Module type <code><span>Interfaces.COMBINATOR_WITH_POSITION</span></code></h1></header><nav class="odoc-toc"><ul><li><a href="#basic-combinators">Basic Combinators</a></li><li><a href="#state-combinators">State Combinators</a></li><li><a href="#optional-elements">Optional Elements</a></li><li><a href="#repetition">Repetition</a></li><li><a href="#parenthesized-expressions">Parenthesized expressions</a></li><li><a href="#operator-expressions">Operator expressions</a></li><li><a href="#backtracking">Backtracking</a></li><li><a href="#location-combinators">Location Combinators</a></li><li><a href="#indentation-combinators">Indentation Combinators</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-state"><a href="#type-state" class="anchor"></a><code><span><span class="keyword">type</span> state</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-expect"><a href="#type-expect" class="anchor"></a><code><span><span class="keyword">type</span> expect</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-semantic"><a href="#type-semantic" class="anchor"></a><code><span><span class="keyword">type</span> semantic</span></code></div></div><h3 id="basic-combinators"><a href="#basic-combinators" class="anchor"></a>Basic Combinators</h3><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>_ t</span></span></code></div><div class="spec-doc"><p><code>'a t</code> Type of a parse combinator returning an <code>'a</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(&gt;&gt;=)"><a href="#val-(&gt;&gt;=)" class="anchor"></a><code><span><span class="keyword">val</span> (&gt;&gt;=) : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>p &gt;&gt;= f</code></p><p>Parse first the input according to the combinator <code>p</code>. In case of success, feed the returned value of <code>p</code> into the function <code>f</code> to get the combinator to parse next.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-let*"><a href="#val-let*" class="anchor"></a><code><span><span class="keyword">val</span> let* : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>let* x = p in f x</code> is equivalent to <code>p &gt;&gt;= f</code></p><p>The <code>let*</code> combinator let us express parsing sequences conveniently. Example:</p><pre class="language-ocaml"><code>let* x = p in       (* parse [p], result [x] in case of success. *)
let* y = q x in     (* parse [q x], result [y] ... *)
let* z = r x y in   (* ... *)
...
return f x y z ...</code></pre><p>The wildcard <code>let* _ = ...</code> can be used to ignore results of intermediate parsing steps.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-map"><a href="#val-map" class="anchor"></a><code><span><span class="keyword">val</span> map : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>map f p</code></p><p>Try combinator <code>p</code>. In case of success, map the returned value <code>x</code> to <code>f
        x</code>. In case of failure, do nothing.</p><p><code>map f p</code> is equivalent to <code>let* x = p in return (f x)</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-map_and_update"><a href="#val-map_and_update" class="anchor"></a><code><span><span class="keyword">val</span> map_and_update : <span><span>(<span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> * <a href="#type-state">state</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>map_and_update f p</code></p><p>Try combinator <code>p</code>. In case of success, map the returned state <code>state</code> and value <code>a</code> to <code>f state a</code>. In case of failure, do nothing.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-succeed"><a href="#val-succeed" class="anchor"></a><code><span><span class="keyword">val</span> succeed : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>succeed a</code></p><p>Succeed immediately without consuming token. Return object <code>a</code> as result.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-return"><a href="#val-return" class="anchor"></a><code><span><span class="keyword">val</span> return : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>return a</code> is equivalent to <code>succeed a</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-unexpected"><a href="#val-unexpected" class="anchor"></a><code><span><span class="keyword">val</span> unexpected : <span><a href="#type-expect">expect</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>unexpected expect</code> triggers a syntax error signalling the expectation <code>expect</code>.</p><ul class="at-tags"><li class="deprecated"><span class="at-tag">deprecated</span> <p>Don't use this function. It will be removed in future versions.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-clear_last_expectation"><a href="#val-clear_last_expectation" class="anchor"></a><code><span><span class="keyword">val</span> clear_last_expectation : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>clear_last_expectation p</code> Clear last failed expectation.</p><p>This is useful e.g. after stripping whitespace. Since stripping whitespace means <code>skip_one_or_more ws</code> or <code>skip_zero_or_more ws</code>, after skipping whitespace the parser can still expect more whitespace. Therefore there is a failed expectation *whitespace* on the stack. However you rarely want this expectation to be reported.</p><ul class="at-tags"><li class="deprecated"><span class="at-tag">deprecated</span> <p>Use <a href="#val-no_expectations"><code>no_expectations</code></a></p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fail"><a href="#val-fail" class="anchor"></a><code><span><span class="keyword">val</span> fail : <span><a href="#type-semantic">semantic</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>fail error</code> triggers a semantic error.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(&lt;/&gt;)"><a href="#val-(&lt;/&gt;)" class="anchor"></a><code><span><span class="keyword">val</span> (&lt;/&gt;) : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>p &lt;/&gt; q</code></p><p>Try first combinator <code>p</code>. In case of success or failure with consumed token, <code>p &lt;/&gt; q</code> is equivalent to <code>p</code>.</p><p>If <code>p</code> fails without consuming token, then <code>p &lt;/&gt; q</code> is equivalent to <code>q</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-choices"><a href="#val-choices" class="anchor"></a><code><span><span class="keyword">val</span> choices : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>choices p [q r t ...]</code> is equivalent to <code>p &lt;/&gt; q &lt;/&gt; r &lt;/&gt; t &lt;/&gt; ...</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(&lt;?&gt;)"><a href="#val-(&lt;?&gt;)" class="anchor"></a><code><span><span class="keyword">val</span> (&lt;?&gt;) : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-expect">expect</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>p &lt;?&gt; expect</code></p><p>Try combinator <code>p</code>. In case of success or failure with consumed token, <code>p &lt;?&gt; expect</code> is equivalent to <code>p</code>.</p><p>If <code>p</code> fails without consuming token, then the failed expectations are replaced with the failed expectation <code>expect</code>.</p><p>Usually <code>p</code> is a combinator implementing a choice between various alternatives of a grammar construct. The <code>&lt;?&gt;</code> combinator allows to replace the set of failed grammar alternatives with a higher abstraction of the failed expectation. E.g. instead of getting the failed expectations <code>identifier</code>, <code>'('</code>, <code>-</code>, ... we can get the failed expectation <code>expression</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-no_expectations"><a href="#val-no_expectations" class="anchor"></a><code><span><span class="keyword">val</span> no_expectations : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>no_expectations p</code></p><p>Parse the combinator <code>p</code>.</p><ul><li><code>p</code> fails: <code>no_expectations p</code> fails with the same error.</li></ul><ul><li><code>p</code> succeeds without consuming tokens: <code>no_expectations p</code> succeeds without any added expectations.</li></ul><ul><li><code>p</code> succeeds and consumes some token: <code>no_expectations p</code> succeeds without any expectations.</li></ul><p>Many combinators can succeed with expectations. E.g. the combinator <a href="#val-optional"><code>optional p</code></a> expects a <code>p</code> and succeeds if it does not encounter a construct described by <code>p</code>. All repetitive combinators like <a href="#val-one_or_more"><code>one_or_more</code></a> try to consume as many items as possible. At the end they are still expecting an item.</p><p>This combinator allows to clear such unneeded expectations. It is particularly useful when removing whitespace. The expectation of whitespace is not a meaningful error message to the user.</p></div></div><h3 id="state-combinators"><a href="#state-combinators" class="anchor"></a>State Combinators</h3><div class="odoc-spec"><div class="spec value anchored" id="val-get"><a href="#val-get" class="anchor"></a><code><span><span class="keyword">val</span> get : <span><a href="#type-state">state</a> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Get the current user state.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-set"><a href="#val-set" class="anchor"></a><code><span><span class="keyword">val</span> set : <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Set the user state.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-update"><a href="#val-update" class="anchor"></a><code><span><span class="keyword">val</span> update : <span><span>(<span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-state">state</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>update f</code> Update the user state using <code>f</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_and_update"><a href="#val-get_and_update" class="anchor"></a><code><span><span class="keyword">val</span> get_and_update : <span><span>(<span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-state">state</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-state">state</a> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>get_and_update f</code> Get the current user state and then update the user state. The returned value is the old state.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-state_around"><a href="#val-state_around" class="anchor"></a><code><span><span class="keyword">val</span> state_around : 
  <span><span>(<span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-state">state</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-state">state</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>state_around before p after</code></p><p>If <code>s0</code> is the initial state, then execute <code>p</code> with the start state <code>before s0</code> and set the update the final state <code>s1</code> by <code>after s0 a s1</code> where <code>a</code> is the returned value in case of success and <code>s1</code> is the final state after executing <code>p</code>.</p></div></div><h3 id="optional-elements"><a href="#optional-elements" class="anchor"></a>Optional Elements</h3><div class="odoc-spec"><div class="spec value anchored" id="val-optional"><a href="#val-optional" class="anchor"></a><code><span><span class="keyword">val</span> optional : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> option</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>optional p</code></p><p>Try combinator <code>p</code>.</p><ul><li>Success: Return <code>Some a</code> where <code>a</code> is the returned value.</li><li>Failure without consuming token: Return <code>None</code></li><li>Failure with consuming token: Remain in the error state.</li></ul></div></div><h3 id="repetition"><a href="#repetition" class="anchor"></a>Repetition</h3><div class="odoc-spec"><div class="spec value anchored" id="val-zero_or_more_fold_left"><a href="#val-zero_or_more_fold_left" class="anchor"></a><code><span><span class="keyword">val</span> zero_or_more_fold_left : <span><span class="type-var">'r</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'r</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'r</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'r</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>zero_or_more_fold_left start f p</code></p><p>Try the combinator <code>p</code> as often as possible. Accumulate the results to the start value <code>start</code> using the folding function <code>f</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-one_or_more_fold_left"><a href="#val-one_or_more_fold_left" class="anchor"></a><code><span><span class="keyword">val</span> one_or_more_fold_left : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'r</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'r</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'r</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'r</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>one_or_more_fold_left first f p</code></p><p>Try the combinator <code>p</code> at least once and then as often as possible. Put the first value returned by <code>p</code> into the function <code>first</code> returning a result and accumulate the subsequent values as often as possible and accumulate the results to the start value returned by <code>first</code> using the folding function <code>f</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-zero_or_more"><a href="#val-zero_or_more" class="anchor"></a><code><span><span class="keyword">val</span> zero_or_more : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>zero_or_more p</code> Parse zero or more occurrences of <code>p</code> and return the collected result in a list.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-one_or_more"><a href="#val-one_or_more" class="anchor"></a><code><span><span class="keyword">val</span> one_or_more : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span><span class="type-var">'a</span> list</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>zero_or_more p</code> Parse one or more occurrences of <code>p</code> and return the collected results as a pair of the first value and a list of the remaining values.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-skip_zero_or_more"><a href="#val-skip_zero_or_more" class="anchor"></a><code><span><span class="keyword">val</span> skip_zero_or_more : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>int <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>skip_zero_or_more p</code> Parse zero or more occurrences of <code>p</code>, ignore the result and return the number of occurrences.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-skip_one_or_more"><a href="#val-skip_one_or_more" class="anchor"></a><code><span><span class="keyword">val</span> skip_one_or_more : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>int <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>skip_one_or_more p</code> Parse one or more occurrences of <code>p</code>, ignore the result and return the number of occurrences.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-one_or_more_separated"><a href="#val-one_or_more_separated" class="anchor"></a><code><span><span class="keyword">val</span> one_or_more_separated : 
  <span><span>(<span><span class="type-var">'item</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'r</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'r</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'sep</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'item</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'r</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'item</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'sep</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'r</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>one_or_more_separated first next p sep</code></p><p>Parse one or more occurrences of <code>p</code> separated by <code>sep</code>. Use <code>first</code> to convert the first occurrence of <code>p</code> into the result and use <code>next</code> to accumulate the results.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-counted"><a href="#val-counted" class="anchor"></a><code><span><span class="keyword">val</span> counted : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'r</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'e</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'r</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'r</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'e</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'r</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>counted min max start next p</code></p><p>Collect between <code>min</code> and <code>max</code> numbers if elements recognized by the combinator <code>p</code> and accumulate them with the folding function <code>next</code> into the start value <code>start</code>.</p></div></div><h3 id="parenthesized-expressions"><a href="#parenthesized-expressions" class="anchor"></a>Parenthesized expressions</h3><div class="odoc-spec"><div class="spec value anchored" id="val-parenthesized"><a href="#val-parenthesized" class="anchor"></a><code><span><span class="keyword">val</span> parenthesized : 
  <span><span>(<span><span class="type-var">'lpar</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'rpar</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'lpar</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'lpar</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'rpar</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>parenthesized make lpar p rpar</code></p><p>Parse an expression recognized by the combinator <code>p</code> enclosed within parentheses. <code>lpar</code> recognizes the left parenthesis and <code>rpar</code> recognizes the right parenthesis. The value returned by <code>lpar</code> is given to <code>rpar</code>. With that mechanism it is possible to recognize matching parentheses of different kinds.</p><p>After successful parsing the function <code>make</code> is called with the final value (and the parentheses).</p><p>The combinator <code>p</code> is entered as a thunk in order to be able to call it recursively. In the combinator <code>parenthesized</code> the combinator <code>p</code> is called only guardedly. Therefore the combinator <code>p</code> can contain nested parenthesized expressions.</p><p>Precondition: The combinator <code>lpar</code> has to consume at least one token in case of success.</p></div></div><h3 id="operator-expressions"><a href="#operator-expressions" class="anchor"></a>Operator expressions</h3><div class="odoc-spec"><div class="spec value anchored" id="val-operator_expression"><a href="#val-operator_expression" class="anchor"></a><code><span><span class="keyword">val</span> operator_expression : 
  <span><span><span class="type-var">'exp</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span><span class="type-var">'op</span> <a href="#type-t">t</a></span> option</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'op</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'op</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'op</span> <span class="arrow">&#45;&gt;</span></span> <span>bool <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'op</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'exp</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'exp</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'exp</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'op</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'exp</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'exp</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'exp</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><pre class="language-ocaml"><code>operator_expression
    primary         (* Parse a primary expression *)
    unary_operator  (* Parse a unary operator *)
    binary_operator (* Parse a binary operator *)
    is_left         (* Is the left operator binding stronger? *)
    make_unary      (* Make a unary expression from the operator and
                       its operand *)
    make_binary     (* Make a binary expression from the operator
                       and its operands *)</code></pre><p>Parse an operator expression by using the following combinators:</p><ul><li><code>is_left o1 o2</code> decides, if the operator <code>o1</code> on the left has more binding power than the operator <code>o2</code>. I.e. if the unary operator <code>u</code> has more binding power than the binary operator <code>o</code>, then <code>u a o b</code> is parsed as <code>(u a) o b</code>. If the binary operator <code>o1</code> has more binding power than the binary operator <code>o2</code>, then <code>a o1 b o2 b</code> is parsed as <code>(a
        o1 b) o2 c</code>.</li></ul><ul><li><code>make_unary u a</code> makes the unary expression <code>(u a)</code>.</li></ul><ul><li><code>make_binary a o b</code> makes the binary expression <code>(a o b)</code>.</li></ul><ul><li><code>primary</code> parses a primary expression.</li></ul><ul><li><code>unary_operator</code> parses a unary operator.</li></ul><ul><li><code>binary_operator</code> parses a binary operator.</li></ul><p>Precondition: <code>primary</code>, <code>unary_operator</code> and <code>binary_operator</code> have to consume at least one token in case of success. Otherwise infinite recursion can happen.</p></div></div><h3 id="backtracking"><a href="#backtracking" class="anchor"></a>Backtracking</h3><div class="odoc-spec"><div class="spec value anchored" id="val-backtrack"><a href="#val-backtrack" class="anchor"></a><code><span><span class="keyword">val</span> backtrack : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-expect">expect</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>backtrack p expect</code></p><p>Try the combinator <code>p</code>. In case of failure with consuming token, push the consumed token back to the lookahead and let it fail without consuming token. Use <code>expect</code> to record the failed expectation.</p><p>Backtracking reduces the performance, because the token pushed back to the lookahead have to be parsed again. Try to avoid backtracking whenever possible.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-followed_by"><a href="#val-followed_by" class="anchor"></a><code><span><span class="keyword">val</span> followed_by : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-expect">expect</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>followed_by p expect</code></p><p>Parses <code>p</code> and backtracks (i.e. all tokens of <code>p</code> will be pushed back to the lookahead). In case <code>p</code> succeeds, the <code>followed_by</code> parser succeeds without consuming token. Otherwise it fails without consuming tokens.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-not_followed_by"><a href="#val-not_followed_by" class="anchor"></a><code><span><span class="keyword">val</span> not_followed_by : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-expect">expect</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>not_followed_by p expect</code></p><p>Parses <code>p</code> and backtracks (i.e. all tokens of <code>p</code> will be pushed back to the lookahead). In case <code>p</code> succeeds, the <code>not_followed_by</code> parser fails without consuming token. Otherwise it succeeds without consuming tokens.</p></div></div><p><code>followed_by</code> and <code>not_followed_by</code> can be used to peek into the token stream without consuming token.</p><h2 id="location-combinators"><a href="#location-combinators" class="anchor"></a>Location Combinators</h2><div class="odoc-spec"><div class="spec value anchored" id="val-located"><a href="#val-located" class="anchor"></a><code><span><span class="keyword">val</span> located : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="../../Located/index.html#type-t">Located.t</a></span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>located p</code> Parse <code>p</code> and return its result with its start and end position.</p><p>Note: If <code>p</code> removes whitespace at the end, the returned end position is at the end of the whitespace. This is not what you usually want. Therefore first parse the essential part located and then remove the whitespace.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-position"><a href="#val-position" class="anchor"></a><code><span><span class="keyword">val</span> position : <span><a href="../../Position/index.html#type-t">Position.t</a> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>The current position in the file.</p></div></div><h2 id="indentation-combinators"><a href="#indentation-combinators" class="anchor"></a>Indentation Combinators</h2><p>The indentation of a normal construct is the indentation of its leftmost token. The indentation of a vertically aligned construct is the indentation of its first token.</p><div class="odoc-spec"><div class="spec value anchored" id="val-indent"><a href="#val-indent" class="anchor"></a><code><span><span class="keyword">val</span> indent : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>indent i p</code> Indent <code>p</code> by <code>i</code> columns relative to its parent.</p><p>Precondition: <code>0 &lt;= i</code></p><p>The indentation of <code>p</code> is defined by the indentation of its first token. The first token has to be indented at least <code>i</code> columns relative to the parent of <code>p</code>. After the first token of <code>p</code> has been parsed successfully, all subsequent tokens must have at least the same indentation.</p><p>Note: Indentation of <code>p</code> relative to its parent only makes sense, if the first token of <code>p</code> is not the first token of its parent! I.e. the parent of <code>p</code> should have consumed at least one token before the parsing of <code>p</code> starts.</p></div></div><p>CAUTION WITH ALIGNMENT !!</p><p>If you want to align a certain number of constructs vertically it is <em>mandatory</em> to indent the whole block of constructs. Do not indent the individual items to be aligned. Indent the whole block.</p><p>Reason: The parent of the block usually has already consumed some token and the indentation of a construct is the position of the leftmost token. If you don't indent the aligned block, then it will be aligned with the leftmost token of the parent construct. This is usually not intended and a common pitfall. Any indentation e.g. zero indentation is ok.</p><div class="odoc-spec"><div class="spec value anchored" id="val-align"><a href="#val-align" class="anchor"></a><code><span><span class="keyword">val</span> align : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>align p</code></p><p>Use the start position of the first token of <code>p</code> to align it with other constructs. If <code>p</code> does not consume any token, then <code>align p</code> has no effect.</p><p>Alignment makes sense if there are at least two combinators which are aligned and indented. E.g. suppose there are two combinators <code>p</code> and <code>q</code>. Then we can form</p><pre class="language-ocaml"><code>indent 1 (
        let* a = align p in
        let* b = align q in
        return (a,b)
)</code></pre><p>This combinator parses <code>p</code> whose first token has to be indented at least one column relative to its parent. And then it parses <code>q</code> whose first token must be aligned with the first token of <code>p</code>.</p><p>The indentation decouples the alignment of <code>p</code> and <code>q</code> with other aligned siblings or parents. <code>indent 0 ...</code> can be used to make the indentation optional.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-left_align"><a href="#val-left_align" class="anchor"></a><code><span><span class="keyword">val</span> left_align : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>left_align p</code></p><p>Align a construct described by <code>p</code> at its leftmost possible column. If a whole block of constructs have to be vertically left aligned, then it is important that at least the first construct is left aligned. The subsequent constructs will be aligned exactly vertically. For the subsequent constructs <code>left_align</code> has the same effect as <a href="#val-align"><code>align</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-detach"><a href="#val-detach" class="anchor"></a><code><span><span class="keyword">val</span> detach : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>detach p</code> Parse <code>p</code> without any indentation and alignment restrictions.</p><p>Detachment is needed to parse whitespace. The whitespace at the beginning of a line never satisfies any nontrivial indentation or aligment requirements.</p></div></div></div></body></html>