<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>LEXER (fmlib_parse.Fmlib_parse.Interfaces.LEXER)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../../index.html">Index</a> &#x00BB; <a href="../../../index.html">fmlib_parse</a> &#x00BB; <a href="../../index.html">Fmlib_parse</a> &#x00BB; <a href="../index.html">Interfaces</a> &#x00BB; LEXER</nav><header class="odoc-preamble"><h1>Module type <code><span>Interfaces.LEXER</span></code></h1><p>A lexer is a restartable parser where the tokens are characters.</p><p>A lexer analyses a stream of characters and groups the stream of characters into tokens. It usually strips off whitespace. I.e. a lexer expects a stream of characters of the form</p><pre>    WS Token WS Token ... WS Token WS EOS</pre><p><code>WS</code> is a possibly empty sequence of whitespace characters like blanks, tabs and newlines and comments. <code>Token</code> represents a legal token. <code>EOS</code> represents the end of the stream.</p><p>A lexer is in one of three states:</p><ul><li><a href="#val-needs_more"><code>needs_more</code></a>: The lexer needs more characters from the stream of characters in order to decide the next correct token or the end of input. The lexer is ready to receive more characters via <a href="#val-put"><code>put</code></a> or to receive the end of input via <a href="#val-put_end"><code>put_end</code></a>.</li></ul><ul><li><a href="#val-has_succeeded"><code>has_succeeded</code></a>: The lexer has found a correct token or detected the end of input. In this state (except at the end of inpute) the lexer can be restarted to find the next token.</li></ul><ul><li><a href="#val-has_failed_syntax"><code>has_failed_syntax</code></a>: The lexer has detected a character (or the end of intput) which cannot be part of a legal token.</li></ul><p>In the state <a href="#val-has_succeeded"><code>has_succeeded</code></a> the lexer signals via <a href="#val-has_consumed_end"><code>has_consumed_end</code></a> that the end of input has been reached.</p><p>A module conforming to the module type <code>LEXER</code> can be used in the module <a href="../../Parse_with_lexer/index.html"><code>Parse_with_lexer</code></a> to create a two stage parser where the lexer handles tokens and a combinator parser handles the higher level constructs.</p></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#feeding-tokens">Feeding Tokens</a></li><li><a href="#success">Success</a></li><li><a href="#syntax-errors">Syntax Errors</a></li><li><a href="#lookahead">Lookahead</a></li><li><a href="#position">Position</a></li><li><a href="#start">Start</a></li><li><a href="#restart">Restart</a></li></ul></nav></div><div class="odoc-content"><p>A parser <code>p</code> is a sink of token. As long as it signals <code>needs_more p</code> more token can be pushed into the parser via <code>put token p</code> or the input stream can be ended via <code>put_end p</code>.</p><p><code>has_ended  p</code> is equivalent to <code>not (needs_more p)</code>. <code>has_ended  p</code> signals that the parser has either succeeded or failed.</p><p>If it has succeeded the final value is available via <code>final p</code>.</p><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div><div class="spec-doc"><p>Type of the parser.</p></div></div><h2 id="feeding-tokens"><a href="#feeding-tokens" class="anchor"></a>Feeding Tokens</h2><div class="odoc-spec"><div class="spec type anchored" id="type-token"><a href="#type-token" class="anchor"></a><code><span><span class="keyword">type</span> token</span></code></div><div class="spec-doc"><p>Type of the tokens.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-item"><a href="#type-item" class="anchor"></a><code><span><span class="keyword">type</span> item</span><span> = <a href="#type-token">token</a></span></code></div><div class="spec-doc"><p>In order to conform to the interface <a href="../../../../fmlib_std/Fmlib_std/Interfaces/module-type-SINK/index.html"><code>Fmlib_std.Interfaces.SINK</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-needs_more"><a href="#val-needs_more" class="anchor"></a><code><span><span class="keyword">val</span> needs_more : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>needs_more p</code> Does the parser <code>p</code> need more tokens?</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-put"><a href="#val-put" class="anchor"></a><code><span><span class="keyword">val</span> put : <span><a href="#type-token">token</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>put tok p</code> Push token <code>tok</code> into the parser <code>p</code>.</p><p>Even if the parser has ended, more tokens can be pushed into the parser. The parser stores the token as lookahead token.</p><p>If the parser has already received the end of the token stream via <a href="#val-put_end"><code>put_end</code></a>, then all subsequent tokens are ignored.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-put_end"><a href="#val-put_end" class="anchor"></a><code><span><span class="keyword">val</span> put_end : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>put_end p</code> Push and end token into the parser <code>p</code>.</p></div></div><h2 id="success"><a href="#success" class="anchor"></a>Success</h2><div class="odoc-spec"><div class="spec type anchored" id="type-final"><a href="#type-final" class="anchor"></a><code><span><span class="keyword">type</span> final</span></code></div><div class="spec-doc"><p>Type of the final result.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-has_succeeded"><a href="#val-has_succeeded" class="anchor"></a><code><span><span class="keyword">val</span> has_succeeded : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>has_succeeded p</code> Has the parser <code>p</code> succeeded?</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-has_ended"><a href="#val-has_ended" class="anchor"></a><code><span><span class="keyword">val</span> has_ended : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>has_ended p</code> Has the parser <code>p</code> ended parsing and either succeeded or failed?</p><p><code>has_ended p</code> is the same as <code>not (needs_more p)</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-final"><a href="#val-final" class="anchor"></a><code><span><span class="keyword">val</span> final : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-final">final</a></span></code></div><div class="spec-doc"><p><code>final p</code> The final object constructed by the parser <code>p</code> in case of success.</p><p>Precondition: <code>has_succeeded p</code></p></div></div><h2 id="syntax-errors"><a href="#syntax-errors" class="anchor"></a>Syntax Errors</h2><div class="odoc-spec"><div class="spec type anchored" id="type-expect"><a href="#type-expect" class="anchor"></a><code><span><span class="keyword">type</span> expect</span><span> = string * <span><a href="../../Indent/index.html#type-expectation">Indent.expectation</a> option</span></span></code></div><div class="spec-doc"><p>Type of expectations.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-has_failed_syntax"><a href="#val-has_failed_syntax" class="anchor"></a><code><span><span class="keyword">val</span> has_failed_syntax : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>has_failed_syntax p</code> Has the parser <code>p</code> failed with a syntax error?</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-failed_expectations"><a href="#val-failed_expectations" class="anchor"></a><code><span><span class="keyword">val</span> failed_expectations : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-expect">expect</a> list</span></span></code></div><div class="spec-doc"><p><code>failed_expectations p</code> The failed expectations due to a syntax error.</p><p>Precondition: <code>has_failed_syntax p</code></p></div></div><h2 id="lookahead"><a href="#lookahead" class="anchor"></a>Lookahead</h2><div class="odoc-spec"><div class="spec value anchored" id="val-has_consumed_end"><a href="#val-has_consumed_end" class="anchor"></a><code><span><span class="keyword">val</span> has_consumed_end : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Has the lexer consumed the end of input?</p></div></div><h2 id="position"><a href="#position" class="anchor"></a>Position</h2><div class="odoc-spec"><div class="spec value anchored" id="val-position"><a href="#val-position" class="anchor"></a><code><span><span class="keyword">val</span> position : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../Position/index.html#type-t">Position.t</a></span></code></div><div class="spec-doc"><p>Line and column number of the current position of the lexer.</p></div></div><h2 id="start"><a href="#start" class="anchor"></a>Start</h2><div class="odoc-spec"><div class="spec value anchored" id="val-start"><a href="#val-start" class="anchor"></a><code><span><span class="keyword">val</span> start : <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>The lexer for the first token.</p></div></div><h2 id="restart"><a href="#restart" class="anchor"></a>Restart</h2><p>A lexer does not consume the entire input stream. It just consumes characters until a token has been recognized. In case of the successful recognition of a token, it returns the token (see <a href="#type-final"><code>final</code></a>). Then it can be restarted to recognize the next token.</p><div class="odoc-spec"><div class="spec value anchored" id="val-restart"><a href="#val-restart" class="anchor"></a><code><span><span class="keyword">val</span> restart : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>restart p</code></p><p>Next lexer, ready to recognize the next token of the input stream.</p><p>All lookaheads from the previous lexer are pushed onto the new lexer which starts a the position where the previous lexer finished.</p><p>Preconditions:</p><ul><li><code>has_succeeded p</code></li><li><code>not (has_consumed_end p)</code></li></ul></div></div></div></body></html>
