<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>COMBINATOR (fmlib_parse.Fmlib_parse.Interfaces.COMBINATOR)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../../index.html">Index</a> &#x00BB; <a href="../../../index.html">fmlib_parse</a> &#x00BB; <a href="../../index.html">Fmlib_parse</a> &#x00BB; <a href="../index.html">Interfaces</a> &#x00BB; COMBINATOR</nav><header class="odoc-preamble"><h1>Module type <code><span>Interfaces.COMBINATOR</span></code></h1></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#basic-combinators">Basic Combinators</a></li><li><a href="#state-combinators">State Combinators</a></li><li><a href="#optional-elements">Optional Elements</a></li><li><a href="#repetition">Repetition</a></li><li><a href="#parenthesized-expressions">Parenthesized expressions</a></li><li><a href="#operator-expressions">Operator expressions</a></li><li><a href="#backtracking">Backtracking</a></li></ul></nav></div><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-state"><a href="#type-state" class="anchor"></a><code><span><span class="keyword">type</span> state</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-expect"><a href="#type-expect" class="anchor"></a><code><span><span class="keyword">type</span> expect</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-semantic"><a href="#type-semantic" class="anchor"></a><code><span><span class="keyword">type</span> semantic</span></code></div></div><h3 id="basic-combinators"><a href="#basic-combinators" class="anchor"></a>Basic Combinators</h3><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>_ t</span></span></code></div><div class="spec-doc"><p><code>'a t</code> Type of a parse combinator returning an <code>'a</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(&gt;&gt;=)"><a href="#val-(&gt;&gt;=)" class="anchor"></a><code><span><span class="keyword">val</span> (&gt;&gt;=) : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>p &gt;&gt;= f</code></p><p>Parse first the input according to the combinator <code>p</code>. In case of success, feed the returned value of <code>p</code> into the function <code>f</code> to get the combinator to parse next.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(let*)"><a href="#val-(let*)" class="anchor"></a><code><span><span class="keyword">val</span> (let*) : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>let* x = p in f x</code> is equivalent to <code>p &gt;&gt;= f</code></p><p>The <code>let*</code> combinator let us express parsing sequences conveniently. Example:</p><pre class="language-ocaml"><code>    let* x = p in       (* parse [p], result [x] in case of success. *)
    let* y = q x in     (* parse [q x], result [y] ... *)
    let* z = r x y in   (* ... *)
    ...
    return f x y z ...</code></pre><p>The wildcard <code>let* _ = ...</code> can be used to ignore results of intermediate parsing steps.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-map"><a href="#val-map" class="anchor"></a><code><span><span class="keyword">val</span> map : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>map f p</code></p><p>Try combinator <code>p</code>. In case of success, map the returned value <code>x</code> to <code>f x</code>. In case of failure, do nothing.</p><p><code>map f p</code> is equivalent to <code>let* x = p in return (f x)</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-map_and_update"><a href="#val-map_and_update" class="anchor"></a><code><span><span class="keyword">val</span> map_and_update : <span><span>(<span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> * <a href="#type-state">state</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>map_and_update f p</code></p><p>Try combinator <code>p</code>. In case of success, map the returned state <code>state</code> and value <code>a</code> to <code>f state a</code>. In case of failure, do nothing.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-succeed"><a href="#val-succeed" class="anchor"></a><code><span><span class="keyword">val</span> succeed : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>succeed a</code></p><p>Succeed immediately without consuming token. Return object <code>a</code> as result.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-return"><a href="#val-return" class="anchor"></a><code><span><span class="keyword">val</span> return : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>return a</code> is equivalent to <code>succeed a</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-unexpected"><a href="#val-unexpected" class="anchor"></a><code><span><span class="keyword">val</span> unexpected : <span><a href="#type-expect">expect</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>unexpected expect</code> triggers a syntax error signalling the expectation <code>expect</code>.</p><ul class="at-tags"><li class="deprecated"><span class="at-tag">deprecated</span> <p>Don't use this function. It will be removed in future versions.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-clear_last_expectation"><a href="#val-clear_last_expectation" class="anchor"></a><code><span><span class="keyword">val</span> clear_last_expectation : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>clear_last_expectation p</code> Clear last failed expectation.</p><p>This is useful e.g. after stripping whitespace. Since stripping whitespace means <code>skip_one_or_more ws</code> or <code>skip_zero_or_more ws</code>, after skipping whitespace the parser can still expect more whitespace. Therefore there is a failed expectation *whitespace* on the stack. However you rarely want this expectation to be reported.</p><ul class="at-tags"><li class="deprecated"><span class="at-tag">deprecated</span> <p>Use <a href="#val-no_expectations"><code>no_expectations</code></a></p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fail"><a href="#val-fail" class="anchor"></a><code><span><span class="keyword">val</span> fail : <span><a href="#type-semantic">semantic</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>fail error</code> triggers a semantic error.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(&lt;/&gt;)"><a href="#val-(&lt;/&gt;)" class="anchor"></a><code><span><span class="keyword">val</span> (&lt;/&gt;) : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>p &lt;/&gt; q</code></p><p>Try first combinator <code>p</code>. In case of success or failure with consumed token, <code>p &lt;/&gt; q</code> is equivalent to <code>p</code>.</p><p>If <code>p</code> fails without consuming token, then <code>p &lt;/&gt; q</code> is equivalent to <code>q</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-choices"><a href="#val-choices" class="anchor"></a><code><span><span class="keyword">val</span> choices : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>choices p [q r t ...]</code> is equivalent to <code>p &lt;/&gt; q &lt;/&gt; r &lt;/&gt; t &lt;/&gt; ...</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(&lt;?&gt;)"><a href="#val-(&lt;?&gt;)" class="anchor"></a><code><span><span class="keyword">val</span> (&lt;?&gt;) : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-expect">expect</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>p &lt;?&gt; expect</code></p><p>Try combinator <code>p</code>. In case of success or failure with consumed token, <code>p &lt;?&gt; expect</code> is equivalent to <code>p</code>.</p><p>If <code>p</code> fails without consuming token, then the failed expectations are replaced with the failed expectation <code>expect</code>.</p><p>Usually <code>p</code> is a combinator implementing a choice between various alternatives of a grammar construct. The <code>&lt;?&gt;</code> combinator allows to replace the set of failed grammar alternatives with a higher abstraction of the failed expectation. E.g. instead of getting the failed expectations <code>identifier</code>, <code>'('</code>, <code>-</code>, ... we can get the failed expectation <code>expression</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-no_expectations"><a href="#val-no_expectations" class="anchor"></a><code><span><span class="keyword">val</span> no_expectations : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>no_expectations p</code></p><p>Parse the combinator <code>p</code>.</p><ul><li><code>p</code> fails: <code>no_expectations p</code> fails with the same error.</li></ul><ul><li><code>p</code> succeeds without consuming tokens: <code>no_expectations p</code> succeeds without any added expectations.</li></ul><ul><li><code>p</code> succeeds and consumes some token: <code>no_expectations p</code> succeeds without any expectations.</li></ul><p>Many combinators can succeed with expectations. E.g. the combinator <a href="#val-optional" title="optional"><code>optional p</code></a> expects a <code>p</code> and succeeds if it does not encounter a construct described by <code>p</code>. All repetitive combinators like <a href="#val-one_or_more"><code>one_or_more</code></a> try to consume as many items as possible. At the end they are still expecting an item.</p><p>This combinator allows to clear such unneeded expectations. It is particularly useful when removing whitespace. The expectation of whitespace is not a meaningful error message to the user.</p></div></div><h3 id="state-combinators"><a href="#state-combinators" class="anchor"></a>State Combinators</h3><div class="odoc-spec"><div class="spec value anchored" id="val-get"><a href="#val-get" class="anchor"></a><code><span><span class="keyword">val</span> get : <span><a href="#type-state">state</a> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Get the current user state.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-set"><a href="#val-set" class="anchor"></a><code><span><span class="keyword">val</span> set : <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Set the user state.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-update"><a href="#val-update" class="anchor"></a><code><span><span class="keyword">val</span> update : <span><span>(<span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-state">state</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>update f</code> Update the user state using <code>f</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_and_update"><a href="#val-get_and_update" class="anchor"></a><code><span><span class="keyword">val</span> get_and_update : <span><span>(<span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-state">state</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-state">state</a> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>get_and_update f</code> Get the current user state and then update the user state. The returned value is the old state.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-state_around"><a href="#val-state_around" class="anchor"></a><code><span><span class="keyword">val</span> state_around : 
  <span><span>(<span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-state">state</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-state">state</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>state_around before p after</code></p><p>If <code>s0</code> is the initial state, then execute <code>p</code> with the start state <code>before s0</code> and set the update the final state <code>s1</code> by <code>after s0 a s1</code> where <code>a</code> is the returned value in case of success and <code>s1</code> is the final state after executing <code>p</code>.</p></div></div><h3 id="optional-elements"><a href="#optional-elements" class="anchor"></a>Optional Elements</h3><div class="odoc-spec"><div class="spec value anchored" id="val-optional"><a href="#val-optional" class="anchor"></a><code><span><span class="keyword">val</span> optional : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> option</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>optional p</code></p><p>Try combinator <code>p</code>.</p><ul><li>Success: Return <code>Some a</code> where <code>a</code> is the returned value.</li><li>Failure without consuming token: Return <code>None</code></li><li>Failure with consuming token: Remain in the error state.</li></ul></div></div><h3 id="repetition"><a href="#repetition" class="anchor"></a>Repetition</h3><div class="odoc-spec"><div class="spec value anchored" id="val-zero_or_more_fold_left"><a href="#val-zero_or_more_fold_left" class="anchor"></a><code><span><span class="keyword">val</span> zero_or_more_fold_left : <span><span class="type-var">'r</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'r</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'r</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'r</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>zero_or_more_fold_left start f p</code></p><p>Try the combinator <code>p</code> as often as possible. Accumulate the results to the start value <code>start</code> using the folding function <code>f</code>. The accumulation happens left to right. I.e. if 3 repetitions are encountered the folding function <code>f</code> is called</p><pre class="language-ocaml"><code>    f (f (f start a1) a2) a3</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-zero_or_more_fold_right"><a href="#val-zero_or_more_fold_right" class="anchor"></a><code><span><span class="keyword">val</span> zero_or_more_fold_right : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'r</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'r</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'r</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'r</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>zero_or_more_fold_left f p start</code></p><p>Try the combinator <code>p</code> as often as possible. Accumulate the results to the start value <code>start</code> using the folding function <code>f</code>. The accumulation happens right to left. I.e. if 3 repetitions are encountered the folding function <code>f</code> is called</p><pre class="language-ocaml"><code>    f a1 (f a2 (f a3 start))</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-one_or_more_fold_left"><a href="#val-one_or_more_fold_left" class="anchor"></a><code><span><span class="keyword">val</span> one_or_more_fold_left : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'r</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'r</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'r</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'r</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>one_or_more_fold_left first f p</code></p><p>Try the combinator <code>p</code> at least once and then as often as possible. Put the first value returned by <code>p</code> into the function <code>first</code> returning a result and accumulate the subsequent values as often as possible and accumulate the results to the start value returned by <code>first</code> using the folding function <code>f</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-zero_or_more"><a href="#val-zero_or_more" class="anchor"></a><code><span><span class="keyword">val</span> zero_or_more : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>zero_or_more p</code> Parse zero or more occurrences of <code>p</code> and return the collected result in a list.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-one_or_more"><a href="#val-one_or_more" class="anchor"></a><code><span><span class="keyword">val</span> one_or_more : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span><span class="type-var">'a</span> list</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>zero_or_more p</code> Parse one or more occurrences of <code>p</code> and return the collected results as a pair of the first value and a list of the remaining values.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-skip_zero_or_more"><a href="#val-skip_zero_or_more" class="anchor"></a><code><span><span class="keyword">val</span> skip_zero_or_more : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>int <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>skip_zero_or_more p</code> Parse zero or more occurrences of <code>p</code>, ignore the result and return the number of occurrences.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-skip_one_or_more"><a href="#val-skip_one_or_more" class="anchor"></a><code><span><span class="keyword">val</span> skip_one_or_more : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>int <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>skip_one_or_more p</code> Parse one or more occurrences of <code>p</code>, ignore the result and return the number of occurrences.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-one_or_more_separated"><a href="#val-one_or_more_separated" class="anchor"></a><code><span><span class="keyword">val</span> one_or_more_separated : 
  <span><span>(<span><span class="type-var">'item</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'r</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'r</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'sep</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'item</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'r</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'item</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'sep</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'r</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>one_or_more_separated first next p sep</code></p><p>Parse one or more occurrences of <code>p</code> separated by <code>sep</code>. Use <code>first</code> to convert the first occurrence of <code>p</code> into the result and use <code>next</code> to accumulate the results.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-counted"><a href="#val-counted" class="anchor"></a><code><span><span class="keyword">val</span> counted : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'r</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'e</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'r</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'r</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'e</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'r</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>counted min max start next p</code></p><p>Collect between <code>min</code> and <code>max</code> numbers if elements recognized by the combinator <code>p</code> and accumulate them with the folding function <code>next</code> into the start value <code>start</code>.</p></div></div><h3 id="parenthesized-expressions"><a href="#parenthesized-expressions" class="anchor"></a>Parenthesized expressions</h3><div class="odoc-spec"><div class="spec value anchored" id="val-parenthesized"><a href="#val-parenthesized" class="anchor"></a><code><span><span class="keyword">val</span> parenthesized : 
  <span><span>(<span><span class="type-var">'lpar</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'rpar</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'lpar</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'lpar</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'rpar</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>parenthesized make lpar p rpar</code></p><p>Parse an expression recognized by the combinator <code>p</code> enclosed within parentheses. <code>lpar</code> recognizes the left parenthesis and <code>rpar</code> recognizes the right parenthesis. The value returned by <code>lpar</code> is given to <code>rpar</code>. With that mechanism it is possible to recognize matching parentheses of different kinds.</p><p>After successful parsing the function <code>make</code> is called with the final value (and the parentheses).</p><p>The combinator <code>p</code> is entered as a thunk in order to be able to call it recursively. In the combinator <code>parenthesized</code> the combinator <code>p</code> is called only guardedly. Therefore the combinator <code>p</code> can contain nested parenthesized expressions.</p><p>Precondition: The combinator <code>lpar</code> has to consume at least one token in case of success.</p></div></div><h3 id="operator-expressions"><a href="#operator-expressions" class="anchor"></a>Operator expressions</h3><div class="odoc-spec"><div class="spec value anchored" id="val-operator_expression"><a href="#val-operator_expression" class="anchor"></a><code><span><span class="keyword">val</span> operator_expression : 
  <span><span><span class="type-var">'exp</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span><span class="type-var">'op</span> <a href="#type-t">t</a></span> option</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'op</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'op</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'op</span> <span class="arrow">&#45;&gt;</span></span> <span>bool <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'op</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'exp</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'exp</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'exp</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'op</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'exp</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'exp</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'exp</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><pre class="language-ocaml"><code>    operator_expression
        primary         (* Parse a primary expression *)
        unary_operator  (* Parse a unary operator *)
        binary_operator (* Parse a binary operator *)
        is_left         (* Is the left operator binding stronger? *)
        make_unary      (* Make a unary expression from the operator and
                           its operand *)
        make_binary     (* Make a binary expression from the operator
                           and its operands *)</code></pre><p>Parse an operator expression by using the following combinators:</p><ul><li><code>is_left o1 o2</code> decides, if the operator <code>o1</code> on the left has more binding power than the operator <code>o2</code>. I.e. if the unary operator <code>u</code> has more binding power than the binary operator <code>o</code>, then <code>u a o b</code> is parsed as <code>(u a) o b</code>. If the binary operator <code>o1</code> has more binding power than the binary operator <code>o2</code>, then <code>a o1 b o2 b</code> is parsed as <code>(a o1 b) o2 c</code>.</li></ul><ul><li><code>make_unary u a</code> makes the unary expression <code>(u a)</code>.</li></ul><ul><li><code>make_binary a o b</code> makes the binary expression <code>(a o b)</code>.</li></ul><ul><li><code>primary</code> parses a primary expression.</li></ul><ul><li><code>unary_operator</code> parses a unary operator.</li></ul><ul><li><code>binary_operator</code> parses a binary operator.</li></ul><p>Precondition: <code>primary</code>, <code>unary_operator</code> and <code>binary_operator</code> have to consume at least one token in case of success. Otherwise infinite recursion can happen.</p></div></div><h3 id="backtracking"><a href="#backtracking" class="anchor"></a>Backtracking</h3><div class="odoc-spec"><div class="spec value anchored" id="val-backtrack"><a href="#val-backtrack" class="anchor"></a><code><span><span class="keyword">val</span> backtrack : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-expect">expect</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>backtrack p expect</code></p><p>Try the combinator <code>p</code>. In case of failure with consuming token, push the consumed token back to the lookahead and let it fail without consuming token. Use <code>expect</code> to record the failed expectation.</p><p>Backtracking reduces the performance, because the token pushed back to the lookahead have to be parsed again. Try to avoid backtracking whenever possible.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-followed_by"><a href="#val-followed_by" class="anchor"></a><code><span><span class="keyword">val</span> followed_by : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-expect">expect</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>followed_by p expect</code></p><p>Parses <code>p</code> and backtracks (i.e. all tokens of <code>p</code> will be pushed back to the lookahead). In case <code>p</code> succeeds, the <code>followed_by</code> parser succeeds without consuming token. Otherwise it fails without consuming tokens.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-not_followed_by"><a href="#val-not_followed_by" class="anchor"></a><code><span><span class="keyword">val</span> not_followed_by : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-expect">expect</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>not_followed_by p expect</code></p><p>Parses <code>p</code> and backtracks (i.e. all tokens of <code>p</code> will be pushed back to the lookahead). In case <code>p</code> succeeds, the <code>not_followed_by</code> parser fails without consuming token. Otherwise it succeeds without consuming tokens.</p></div></div><p><code>followed_by</code> and <code>not_followed_by</code> can be used to peek into the token stream without consuming token.</p></div></body></html>
