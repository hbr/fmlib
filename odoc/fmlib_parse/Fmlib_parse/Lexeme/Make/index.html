<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Make (fmlib_parse.Fmlib_parse.Lexeme.Make)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../../index.html">Index</a> &#x00BB; <a href="../../../index.html">fmlib_parse</a> &#x00BB; <a href="../../index.html">Fmlib_parse</a> &#x00BB; <a href="../index.html">Lexeme</a> &#x00BB; Make</nav><header class="odoc-preamble"><h1>Module <code><span>Lexeme.Make</span></code></h1></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#parameters">Parameters</a></li><li><a href="#signature">Signature</a></li><li><a href="#lexeme-parsers">Lexeme Parsers</a></li><li><a href="#basic-lexeme-support">Basic Lexeme Support</a></li><li><a href="#token">Token</a></li><li><a href="#parenthesized-structures">Parenthesized Structures</a></li><li><a href="#operator-expressions">Operator Expressions</a></li></ul></nav></div><div class="odoc-content"><h2 id="parameters"><a href="#parameters" class="anchor"></a>Parameters</h2><div class="odoc-spec"><div class="spec parameter anchored" id="argument-1-Combi"><a href="#argument-1-Combi" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="argument-1-Combi/index.html">Combi</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec parameter anchored" id="argument-2-Lang"><a href="#argument-2-Lang" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="argument-2-Lang/index.html">Lang</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><h2 id="signature"><a href="#signature" class="anchor"></a>Signature</h2><h2 id="lexeme-parsers"><a href="#lexeme-parsers" class="anchor"></a>Lexeme Parsers</h2><p>In a lexeme parser all tokens strip off whitespace which come after the token. Therefore each combinator starts at a position in the input stream which does not start any whitespace.</p><p>This is true for all tokens except the first token. Therefore the whitespace at the beginning of the stream has to be stripped off separately.</p><p>All tokens in this module strip off the whitespace comming after it. If the parsing of any token fails, then an alternative combinator can take over at the start position of the failed token. The module does the necessary backtracking.</p><p>If the user of the module adds own tokens, the token shall satisfy the same requirement. Strip off all whitespace after the token. In case of failure of a multicharacter token backtracking is done appropriately.</p><h2 id="basic-lexeme-support"><a href="#basic-lexeme-support" class="anchor"></a>Basic Lexeme Support</h2><div class="odoc-spec"><div class="spec value anchored" id="val-whitespace"><a href="#val-whitespace" class="anchor"></a><code><span><span class="keyword">val</span> whitespace : <span>int <a href="argument-1-Combi/index.html#type-t">Combi.t</a></span></span></code></div><div class="spec-doc"><p>Strip off any sequence of whitespace characters and comments. Return the number of characters stripped off.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-whitespace_before"><a href="#val-whitespace_before" class="anchor"></a><code><span><span class="keyword">val</span> whitespace_before : <span><span><span class="type-var">'a</span> <a href="argument-1-Combi/index.html#type-t">Combi.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="argument-1-Combi/index.html#type-t">Combi.t</a></span></span></code></div><div class="spec-doc"><p><code>whitespace_before p</code></p><p>Strip off whitespace and then continue parsing with <code>p</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-lexeme"><a href="#val-lexeme" class="anchor"></a><code><span><span class="keyword">val</span> lexeme : <span><span><span class="type-var">'a</span> <a href="argument-1-Combi/index.html#type-t">Combi.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="argument-1-Combi/index.html#type-t">Combi.t</a></span></span></code></div><div class="spec-doc"><p><code>lexeme p</code></p><p>Convert <code>p</code> to a lexeme parser i.e. strip off any whitespace after successfully parsing with <code>p</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-token"><a href="#val-token" class="anchor"></a><code><span><span class="keyword">val</span> token : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="argument-1-Combi/index.html#type-t">Combi.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="argument-1-Combi/index.html#type-t">Combi.t</a></span></span></code></div><div class="spec-doc"><p><code>token expect p</code></p><p>Convert a token parser <code>p</code> which does not adhere to the conventions of a lexeme parser (i.e. no whitespace stripped after the token, no backtracking in case of failure) into a parser which respects the conventions.</p><p>The string <code>expect</code> describes the expected token. It might appear in error messages.</p></div></div><h2 id="token"><a href="#token" class="anchor"></a>Token</h2><p>All whitespace after tokens is stripped off. If a token fails, then the next alternative can be checked at the start position of the token. No <code>backtrack</code> is necessary.</p><div class="odoc-spec"><div class="spec value anchored" id="val-semicol"><a href="#val-semicol" class="anchor"></a><code><span><span class="keyword">val</span> semicol : <span>char <a href="argument-1-Combi/index.html#type-t">Combi.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-comma"><a href="#val-comma" class="anchor"></a><code><span><span class="keyword">val</span> comma : <span>char <a href="argument-1-Combi/index.html#type-t">Combi.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-colon"><a href="#val-colon" class="anchor"></a><code><span><span class="keyword">val</span> colon : <span>char <a href="argument-1-Combi/index.html#type-t">Combi.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-dot"><a href="#val-dot" class="anchor"></a><code><span><span class="keyword">val</span> dot : <span>char <a href="argument-1-Combi/index.html#type-t">Combi.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-string"><a href="#val-string" class="anchor"></a><code><span><span class="keyword">val</span> string : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span>string <a href="../../Located/index.html#type-t">Located.t</a></span> <a href="argument-1-Combi/index.html#type-t">Combi.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-unsigned_int"><a href="#val-unsigned_int" class="anchor"></a><code><span><span class="keyword">val</span> unsigned_int : <span><span>int <a href="../../Located/index.html#type-t">Located.t</a></span> <a href="argument-1-Combi/index.html#type-t">Combi.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-int"><a href="#val-int" class="anchor"></a><code><span><span class="keyword">val</span> int : <span><span>int <a href="../../Located/index.html#type-t">Located.t</a></span> <a href="argument-1-Combi/index.html#type-t">Combi.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-float"><a href="#val-float" class="anchor"></a><code><span><span class="keyword">val</span> float : <span><span>float <a href="../../Located/index.html#type-t">Located.t</a></span> <a href="argument-1-Combi/index.html#type-t">Combi.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-identifier"><a href="#val-identifier" class="anchor"></a><code><span><span class="keyword">val</span> identifier : <span><span>string <a href="../../Located/index.html#type-t">Located.t</a></span> <a href="argument-1-Combi/index.html#type-t">Combi.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-reserved"><a href="#val-reserved" class="anchor"></a><code><span><span class="keyword">val</span> reserved : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span>string <a href="../../Located/index.html#type-t">Located.t</a></span> <a href="argument-1-Combi/index.html#type-t">Combi.t</a></span></span></code></div></div><h2 id="parenthesized-structures"><a href="#parenthesized-structures" class="anchor"></a>Parenthesized Structures</h2><p>Note that all combinators parsing the inner part of the parentheses have the type <code>unit -&gt; 'a t</code>. The are called only if the opening parenthesis has been parsed successfully. This makes it possible to use the parenthesized structures recursively.</p><div class="odoc-spec"><div class="spec value anchored" id="val-parens"><a href="#val-parens" class="anchor"></a><code><span><span class="keyword">val</span> parens : <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="argument-1-Combi/index.html#type-t">Combi.t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="argument-1-Combi/index.html#type-t">Combi.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-braces"><a href="#val-braces" class="anchor"></a><code><span><span class="keyword">val</span> braces : <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="argument-1-Combi/index.html#type-t">Combi.t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="argument-1-Combi/index.html#type-t">Combi.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-brackets"><a href="#val-brackets" class="anchor"></a><code><span><span class="keyword">val</span> brackets : <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="argument-1-Combi/index.html#type-t">Combi.t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="argument-1-Combi/index.html#type-t">Combi.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-angulars"><a href="#val-angulars" class="anchor"></a><code><span><span class="keyword">val</span> angulars : <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="argument-1-Combi/index.html#type-t">Combi.t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="argument-1-Combi/index.html#type-t">Combi.t</a></span></span></code></div></div><h2 id="operator-expressions"><a href="#operator-expressions" class="anchor"></a>Operator Expressions</h2><div class="odoc-spec"><div class="spec type anchored" id="type-assoc"><a href="#type-assoc" class="anchor"></a><code><span><span class="keyword">type</span> assoc</span><span> = </span></code><ol><li id="type-assoc.Left" class="def variant constructor anchored"><a href="#type-assoc.Left" class="anchor"></a><code><span>| </span><span><span class="constructor">Left</span></span></code></li><li id="type-assoc.Right" class="def variant constructor anchored"><a href="#type-assoc.Right" class="anchor"></a><code><span>| </span><span><span class="constructor">Right</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Associativity of an operator</p><span class="comment-delim">*)</span></div></li></ol></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-unary_operation"><a href="#type-unary_operation" class="anchor"></a><code><span><span class="keyword">type</span> <span>'e unary_operation</span></span><span> = <span><a href="../../Position/index.html#type-range">Position.range</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'e</span> <a href="../../Located/index.html#type-t">Located.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'e</span> <a href="argument-1-Combi/index.html#type-t">Combi.t</a></span></span></code></div><div class="spec-doc"><p>A unary operation is a function, mapping the position of the operator and a located operand into the result. Note that the result is not located. The library computes the location.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-binary_operation"><a href="#type-binary_operation" class="anchor"></a><code><span><span class="keyword">type</span> <span>'e binary_operation</span></span><span> =
  <span><span><span class="type-var">'e</span> <a href="../../Located/index.html#type-t">Located.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Position/index.html#type-range">Position.range</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'e</span> <a href="../../Located/index.html#type-t">Located.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'e</span> <a href="argument-1-Combi/index.html#type-t">Combi.t</a></span></span></code></div><div class="spec-doc"><p>A unary operation is a function, mapping a located left operand, the position of the operator and a located right operand into the result. Note that the result is not located. The library computes the location.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-operation"><a href="#type-operation" class="anchor"></a><code><span><span class="keyword">type</span> <span>'e operation</span></span><span> = </span></code><ol><li id="type-operation.Unary" class="def variant constructor anchored"><a href="#type-operation.Unary" class="anchor"></a><code><span>| </span><span><span class="constructor">Unary</span> <span class="keyword">of</span> <span><span class="type-var">'e</span> <a href="#type-unary_operation">unary_operation</a></span></span></code></li><li id="type-operation.Binary" class="def variant constructor anchored"><a href="#type-operation.Binary" class="anchor"></a><code><span>| </span><span><span class="constructor">Binary</span> <span class="keyword">of</span> <span><span class="type-var">'e</span> <a href="#type-binary_operation">binary_operation</a></span></span></code></li><li id="type-operation.Both" class="def variant constructor anchored"><a href="#type-operation.Both" class="anchor"></a><code><span>| </span><span><span class="constructor">Both</span> <span class="keyword">of</span> <span><span class="type-var">'e</span> <a href="#type-unary_operation">unary_operation</a></span> * <span><span class="type-var">'e</span> <a href="#type-binary_operation">binary_operation</a></span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-operator_table"><a href="#type-operator_table" class="anchor"></a><code><span><span class="keyword">type</span> <span>'e operator_table</span></span><span> = <span><span><span>(string * <a href="#type-assoc">assoc</a> * <span><span class="type-var">'e</span> <a href="#type-operation">operation</a></span>)</span> list</span> list</span></span></code></div><div class="spec-doc"><p>An operator table describes the precedence, associativity and the semantics of operators. It is a list of operators where each entry in the list is a list of operators at the same precedence level.</p><p>The precedences are descending i.e. the first entry in the list are the operators with the highest precedence.</p><p>The following example describes the addition, multiplication and exponentian operators for floating point arithmetic. The addition operators <code>+</code> and <code>-</code> are at the lowest precedence and the exponentiation operator <code>^</code> has the highest precedence.</p><pre class="language-ocaml"><code>    [
        [ &quot;^&quot;, Right, Binary (lift_binary ( ** ))]
        ;
        [ (&quot;*&quot;, Left, Binary (lift_binary ( *. )));
          (&quot;/&quot;, Left, Binary (lift_binary ( /. ))) ]
        ;
        [ (&quot;+&quot;, Left, Both (lift_unary (~+.), lift_binary (+.)));
          (&quot;-&quot;, Left, Both (lift_unary (~-.), lift_binary (-.))) ]
    ]</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-lift_unary"><a href="#val-lift_unary" class="anchor"></a><code><span><span class="keyword">val</span> lift_unary : <span><span>(<span><span class="type-var">'e</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'e</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'e</span> <a href="#type-unary_operation">unary_operation</a></span></span></code></div><div class="spec-doc"><p><code>lift_unary f</code></p><p>Lift the function <code>f</code> doing the unary operation into an <code>'e unary_operation</code> ignoring the location information.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-lift_binary"><a href="#val-lift_binary" class="anchor"></a><code><span><span class="keyword">val</span> lift_binary : <span><span>(<span><span class="type-var">'e</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'e</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'e</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'e</span> <a href="#type-binary_operation">binary_operation</a></span></span></code></div><div class="spec-doc"><p><code>lift_binary f</code></p><p>Lift the function <code>f</code> doing the binary operation into an <code>'e binary_operation</code> ignoring the location information.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-expression"><a href="#val-expression" class="anchor"></a><code><span><span class="keyword">val</span> expression : 
  <span><span>string <a href="argument-1-Combi/index.html#type-t">Combi.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'e</span> <a href="../../Located/index.html#type-t">Located.t</a></span> <a href="argument-1-Combi/index.html#type-t">Combi.t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'e</span> <a href="../../Located/index.html#type-t">Located.t</a></span> <a href="argument-1-Combi/index.html#type-t">Combi.t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'e</span> <a href="#type-operator_table">operator_table</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'e</span> <a href="../../Located/index.html#type-t">Located.t</a></span> <a href="argument-1-Combi/index.html#type-t">Combi.t</a></span></span></code></div><div class="spec-doc"><p><code>expression operator primary table</code></p><p>Make a parser for operator expressions with the following arguments:</p><ul><li><code>operator</code> Parsing combinator of an operator. The combinator needs not respect the conventions for a lexeme parser. The function handles stripping off whitespace and backtracking properly.</li></ul><ul><li><code>primary</code> Parsing combinator for primary expressions. Primary expressions are either tokens (numbers, variables, ...) or more complex expressions which are treated as atomic expressions (e.g. parenthesized expressions, function calls, ...). The <code>primary</code> combinator can use the generated expression parser recursively after cosuming at least one character. This convention is necessary to avoid unbounded recursion.</li></ul><ul><li><code>table</code> Table describing the operators.</li></ul><p>Example: For parser computing floating point expressions use the following:</p><pre class="language-ocaml"><code>    let operator: string t =
        one_of_chars &quot;+-*/^&quot; &quot;One of the operators [+,-,*,/,^]&quot;
        |&gt; map (String.make 1)

    in
    let primary (expr: unit -&gt; float Located.t t): float Located.t t =
        float
        &lt;/&gt;
        parens expr
    in
    expression operator primary table</code></pre><p>where <code>table</code> is the operator table describe above in the description of <a href="#type-operator_table"><code>operator_table</code></a>.</p></div></div></div></body></html>
