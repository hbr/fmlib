<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Web_worker (fmlib_js.Fmlib_js.Web_worker)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">Index</a> &#x00BB; <a href="../../index.html">fmlib_js</a> &#x00BB; <a href="../index.html">Fmlib_js</a> &#x00BB; Web_worker</nav><header class="odoc-preamble"><h1>Module <code><span>Fmlib_js.Web_worker</span></code></h1><p>Create webworker in the main thread and in the worker thread.</p></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#overview">Overview</a><ul><li><a href="#basics">Basics</a></li><li><a href="#creator-code">Creator Code</a></li><li><a href="#implementation-code">Implementation Code</a></li></ul></li><li><a href="#api">API</a><ul><li><a href="#creator-code_2">Creator Code</a></li><li><a href="#implementation-code_2">Implementation Code</a></li><li><a href="#simulation">Simulation</a></li></ul></li></ul></nav></div><div class="odoc-content"><h2 id="overview"><a href="#overview" class="anchor"></a>Overview</h2><h3 id="basics"><a href="#basics" class="anchor"></a>Basics</h3><p>An application using webworker has two parts:</p><ul><li>A creator which creates the webworker</li><li>An implementation of a webworker</li></ul><p>The creator and the worker can communicate only by sending messages. Usually in javascript a webworker is created by</p><pre>    function callback (msg) {
        // actions on receiving messages from the worker
    }
    var worker = new Worker('url_to_worker.js')
    worker.onmessage = callback

    worker.postMessage (...)    // send a message to the worker</pre><p>Then there is a javascript implementation of the worker.</p><pre>    function onmessage (msg) {
        // actions on receiving a message from the creator
        ...
        postMessage (...)       // send a message to the creator
    }

    ...                         // initialization code

    postMessage (...)           // optional initial message to the creator
    ...</pre><p>Both parts the creator part and the implementation part can be implemented in ocaml and this module provides functions to support that.</p><h3 id="creator-code"><a href="#creator-code" class="anchor"></a>Creator Code</h3><p>The call</p><pre class="language-ocaml"><code>    let worker = Web_worker.start &quot;url&quot; decode callback</code></pre><p>starts a worker whose implementation can be found at <code>&quot;url&quot;</code>. <code>decode</code> is a decoder to decode messages from the webworker and the function <code>callback</code> processes the decoded messages.</p><pre class="language-ocaml"><code>    decode: 'msg Decode.t

    callback: 'msg -&gt; unit</code></pre><p>If the message received from the webworker cannot be decoded, the event will be logged via <code>console.log</code>.</p><p>The webworker has a function <code>post</code> to send messages to the worker. I.e. at any time you can call</p><pre class="language-ocaml"><code>    Web_worker.post msg worker</code></pre><p>where <code>msg</code> is an arbitrary javascript value i.e. <code>msg: Value.t</code>.</p><p>The command</p><pre class="language-ocaml"><code>    Web_worker.terminate worker</code></pre><p>terminates the worker.</p><p><em>Warning:</em> If the html where the code of the creator resides has been loaded into the browser with an url like <code>file://....</code>, and the url of the command <code>Webworker.start url decode callback</code> is relative, then the browser cannot load the worker. The worker code must always be loaded from a server (which can be a local server).</p><h3 id="implementation-code"><a href="#implementation-code" class="anchor"></a>Implementation Code</h3><p>In ocaml the implementation of a web worker has two components:</p><ul><li>A decoder <code>decode</code> to decode messages which are received as javascript values into ocaml values.</li></ul><ul><li>An implementation function of the form</li></ul><pre class="language-ocaml"><code>    let worker (post: Value.t -&gt; unit): 'msg -&gt; unit =
        ... (* initialization code *)
        ...
        fun msg -&gt;
            ... (* code executed on receiving a decoded message of type
                   ['msg] *)
            ...</code></pre><p>Having the decoder and the worker function, the actual webworker is made by the command</p><pre class="language-ocaml"><code>    make decode worker</code></pre><p>The <code>make</code> function retrieves the javascript function <code>postMessage</code> which must be available in the implementation environment of a webworker and decodes all incoming messages from the creator. <code>make</code> calls <code>worker</code> in a curried form. First to provide it with the retrieve function <code>postMessage</code> and subsequently on each decoded incoming message.</p><p>If a message from the creator cannot be decoded, then the event is logged in the console.</p><h2 id="api"><a href="#api" class="anchor"></a>API</h2><h3 id="creator-code_2"><a href="#creator-code_2" class="anchor"></a>Creator Code</h3><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div><div class="spec-doc"><p>Type of a web worker in the creator which can receive messages of type <code>'msg</code> from the actual worker.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-start"><a href="#val-start" class="anchor"></a><code><span><span class="keyword">val</span> start : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'msg</span> <a href="../Base/Decode/index.html#type-t">Base.Decode.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'msg</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>start url decode callback</code></p><p>Create a webworker loaded from <code>url</code> and register the callback <code>callback</code> to receive messages from the webworker. Use the decoder <code>decode</code> to decode messages received from the webworker.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-post_message"><a href="#val-post_message" class="anchor"></a><code><span><span class="keyword">val</span> post_message : <span><a href="../Base/Value/index.html#type-t">Base.Value.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>post msg w</code> Post the message <code>msg</code> to the worker <code>w</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-terminate"><a href="#val-terminate" class="anchor"></a><code><span><span class="keyword">val</span> terminate : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>terminate worker</code> Terminate the webworker <code>worker</code>.</p></div></div><h3 id="implementation-code_2"><a href="#implementation-code_2" class="anchor"></a>Implementation Code</h3><div class="odoc-spec"><div class="spec type anchored" id="type-worker_function"><a href="#type-worker_function" class="anchor"></a><code><span><span class="keyword">type</span> <span>'msg worker_function</span></span><span> = <span><span>(<span><a href="../Base/Value/index.html#type-t">Base.Value.t</a> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'msg</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Type of a worker function.</p><p>A worker function <code>f</code> of that type is called in a curried form. In the first call, it receives a function to post messages to its creator.</p><pre class="language-ocaml"><code>    let g = f post</code></pre><p>In subsequent calls, it receives messages from its creator</p><pre class="language-ocaml"><code>    g msg</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-make"><a href="#val-make" class="anchor"></a><code><span><span class="keyword">val</span> make : <span><span><span class="type-var">'msg</span> <a href="../Base/Decode/index.html#type-t">Base.Decode.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'msg</span> <a href="#type-worker_function">worker_function</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>make decode f</code></p><p>Make the actual webworker. <code>decode</code> is a decoder for incoming messages. <code>f</code> is the main function of the worker. <code>f</code> is called in a curried form. The first call is</p><pre class="language-ocaml"><code>    let g = f post</code></pre><p>where <code>post</code> is the function to send messages back to the creator of the worker.</p><p>Then each time a message is received from the creator of the webworker, the message is decoded by <code>decode</code>. In case of success with the ocaml object <code>msg</code> the function call <code>g msg</code> is made.</p><p>The function <code>make</code> might raise 2 possible exceptions:</p><ul><li>It cannot find a global object <code>postMessage</code> i.e. it does not run in a webworker environment.</li></ul><ul><li>It finds a global object <code>postMessage</code> but the object is not a function. This indicates as well that it is not executed in a webworker environment.</li></ul><p>If during the execution of the worker messages arrive which cannot be decoded successfully by <code>decode</code>, then this event is logged.</p></div></div><h3 id="simulation"><a href="#simulation" class="anchor"></a>Simulation</h3><p>Sometimes it is useful to simulated the behaviour of a webworker in the main thread. As opposed to a real webworker, a simulator runs in the main thread and therefore can block the event loop for a certain amount of time.</p><p>Recall that a real webworker is started in the main thread by</p><pre class="language-ocaml"><code>    let worker = Web_worker.start &quot;url&quot; decode callback</code></pre><p>where <code>decode</code> is a decoder for messages received from the worker and <code>callback</code> is a function which is called on each received message from the worker.</p><p>The behaviour of a worker is completely described by the pair <code>(dec,wfun)</code> where <code>dec</code> is a decoder for messages received from the creator and <code>wfun</code> is a workerfunction.</p><p>The simulator is started from the main thread by</p><pre class="language-ocaml"><code>    let worker = Web_worker.Simulate.start decode callback dec fun</code></pre><p>and there are the functions</p><pre class="language-ocaml"><code>    Web_worker.Simulate.post_message msg worker

    Web_worker.Simulate.terminate worker</code></pre><p>to send messages to the worker and to terminate the worker.</p><div class="odoc-spec"><div class="spec module anchored" id="module-Simulate"><a href="#module-Simulate" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Simulate/index.html">Simulate</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Simulate the behaviour of a webworker in the main thread.</p></div></div><p>It is also possible to simulate the behaviour of a web worker written in ocaml within javascript code. Let's assume that the webworker is defined by the pair <code>(decode, wfun)</code>. Then we write an ocaml file with the content</p><pre class="language-ocaml"><code>    let decode = ...

    let wfun = ...

    let _ =
        Web_worker.Simulate.simulate_js &quot;Simulated_worker&quot; decode wfun</code></pre><p>and compile it to <code>worker.js</code>. Then instead of writing a html file</p><pre>&lt;html&gt;
    &lt;body&gt;
        ...
        &lt;script&gt;
            var worker = new Worker(&quot;worker.js&quot;)
            worker.onmessage = (msg) =&gt; {...}
            worker.postMessage (msg)
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;</pre><p>we write the html file</p><pre>&lt;html&gt;
    &lt;head&gt;
        &lt;script type=&quot;text/javascript&quot; src=&quot;worker.js&quot;&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        ...
        &lt;script&gt;
            var worker = Simulated_worker ((msg) =&gt; ... )
            worker.postMessage (msg)
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;</pre><div class="odoc-spec"><div class="spec value anchored" id="val-simulate_js"><a href="#val-simulate_js" class="anchor"></a><code><span><span class="keyword">val</span> simulate_js : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'msg</span> <a href="../Base/Decode/index.html#type-t">Base.Decode.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'msg</span> <a href="#type-worker_function">worker_function</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>simulate_js name decode wfun</code></p><p>Create a simulation of a webworker given by <code>(decode, wfun)</code> and make it accessible from the javascript code under the name <code>name</code>.</p><p>In javascript you write <code>var worker = name (callback)</code> to start the worker and <code>worker.postMessage(msg)</code> to send a message to the worker. Furthermore it is possible to terminate the worker by <code>worker.terminate()</code>.</p></div></div></div></body></html>
